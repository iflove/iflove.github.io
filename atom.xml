<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lazy Notes</title>
  
  <subtitle>Android &amp; Java</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lazy.github.io/"/>
  <updated>2018-01-15T15:17:46.417Z</updated>
  <id>http://lazy.github.io/</id>
  
  <author>
    <name>Lazy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>My Hexo</title>
    <link href="http://lazy.github.io/2018/01/09/hexo/My-Hexo/"/>
    <id>http://lazy.github.io/2018/01/09/hexo/My-Hexo/</id>
    <published>2018-01-09T13:56:44.808Z</published>
    <updated>2018-01-15T15:17:46.417Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><a id="more"></a> <h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo 订阅</p><p>node_modules 下安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-feed --save</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 &lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt;（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://lazy.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://lazy.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>软引用、弱引用和虚引用处理</title>
    <link href="http://lazy.github.io/2017/12/26/java/java-reference-note/"/>
    <id>http://lazy.github.io/2017/12/26/java/java-reference-note/</id>
    <published>2017-12-26T14:50:27.000Z</published>
    <updated>2018-01-09T14:51:18.453Z</updated>
    
    <content type="html"><![CDATA[<p>之前在Android上使用 <code>Handler</code> 引起了内存泄漏。从而认识了弱引用、软引用、虚引用。今天发现Kotlin 在Android 上Anko库里的<code>async</code>, <code>uiThread</code> 里面居然做了在异步执行过程中Activity销毁了uiThread则不会调用，防止内存泄漏。正是采用了弱引用，先温习一下。</p><a id="more"></a> <hr><p>Java中有如下四种类型的引用：</p><ul><li>强引用(Strong Reference)</li><li>软引用(SoftReference)</li><li>弱引用(WeakReference)</li><li>虚引用(PhantomReference)</li></ul><blockquote><p>Java.lang.ref 是 Java 类库中的一个包，它提供了与 Java 垃圾回收器密切相关的引用类。这些引用类对象可以指向其它对象，但它们不同于一般的引用，因为它们的存在并不防碍 Java 垃圾回收器对它们所指向的对象进行回收。其好处就在于使者可以保持对使用对象的引用，同时 JVM 依然可以在内存不够用的时候对使用对象进行回收。因此这个包在用来实现与缓存相关的应用时特别有用。同时该包也提供了在对象的“可达”性发生改变时，进行提醒的机制。</p></blockquote><h2 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h2><p>强引用就是我们经常使用的对象引用。 在Java中没有相应的类与它对应 ，如果一个对象属于强引用，就算内存不足时，JVM情愿抛出OOM异常使程序异常终止也不会靠回收强引用的对象来解决内存不足的问题。</p><h2 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h2><p>SoftReference 在“弱引用”中属于最强的引用。SoftReference 所指向的对象，当没有强引用指向它时，会在内存中停留一段的时间，垃圾回收器会根据 JVM 内存的使用情况（内存的紧缺程度）以及 SoftReference 的 get() 方法的调用情况来决定是否对其进行回收。</p><h2 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference)"></a>弱引用(Weak Reference)</h2><p>WeakReference 是弱于 SoftReference 的引用类型。弱引用的特性和基本与软引用相似，区别就在于弱引用所指向的对象只要进行系统垃圾回收，不管内存使用情况如何，永远对其进行回收（get() 方法返回 null）。</p><h2 id="虚引用-（Phantom-Reference）"><a href="#虚引用-（Phantom-Reference）" class="headerlink" title="虚引用 （Phantom Reference）"></a>虚引用 （Phantom Reference）</h2><p>PhantomReference 是所有“弱引用”中最弱的引用类型。不同于软引用和弱引用，虚引用无法通过 get() 方法来取得目标对象的强引用从而使用目标对象，观察源码可以发现 get() 被重写为永远返回 null。</p><h2 id="引用对列-（Reference-Queue）"><a href="#引用对列-（Reference-Queue）" class="headerlink" title="引用对列 （Reference Queue）"></a>引用对列 （Reference Queue）</h2><p>在适当的时候检测到对象的可达性发生改变后，垃圾回收器就将已注册的引用对象添加到此队列中。一旦弱引用对象开始返回null，该弱引用指向的对象就被标记成了垃圾。而这个弱引用对象（非其指向的对象）就没有什么用了。通常这时候需要进行一些清理工作。比如WeakHashMap会在这时候移除没用的条目来避免保存无限制增长的没有意义的弱引用。</p><h2 id="引用类型特性总结"><a href="#引用类型特性总结" class="headerlink" title="引用类型特性总结"></a>引用类型特性总结</h2><table><thead><tr><th>引用类型</th><th>取得目标对象方式</th><th>垃圾回收条件</th><th>是否可能内存泄漏</th></tr></thead><tbody><tr><td>强引用</td><td>直接调用</td><td>不回收</td><td>可能</td></tr><tr><td>软引用</td><td>通过 get() 方法</td><td>视内存情况回收</td><td>不可能</td></tr><tr><td>弱引用</td><td>通过 get() 方法</td><td>永远回收</td><td>不可能</td></tr><tr><td>虚引用</td><td>无法取得</td><td>不回收</td><td>可能</td></tr></tbody></table><p>理论到实践-&gt;代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ReferenceDemo referenceDemo = <span class="keyword">new</span> ReferenceDemo();</div><div class="line">        <span class="comment">//referenceDemo.strongReference();</span></div><div class="line"></div><div class="line">        referenceDemo.softReference();</div><div class="line">        referenceDemo.weakReference();</div><div class="line">        referenceDemo.phantomReference();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">phantomReference</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"------phantomReference--------"</span>);</div><div class="line">        ReferenceQueue&lt;Object&gt; refQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();</div><div class="line">        PhantomReference&lt;Object&gt; referent = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> Object(), refQueue);</div><div class="line">        System.out.println(referent.get());</div><div class="line">        System.gc();</div><div class="line">        System.runFinalization();</div><div class="line">        System.out.println(String.format(<span class="string">"is recycle %s"</span>, (refQueue.poll()) == referent));</div><div class="line">        System.out.println(<span class="string">"------phantomReference--------"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">weakReference</span><span class="params">()</span> </span>&#123;</div><div class="line">        list.clear();</div><div class="line">        System.out.println(<span class="string">"------WeakReference--------"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">            WeakReference weakReference = <span class="keyword">new</span> WeakReference(buff);</div><div class="line">            list.add(weakReference);</div><div class="line">        &#125;</div><div class="line">        list.forEach(o -&gt; &#123;</div><div class="line">            Object o1 = ((WeakReference) o).get();</div><div class="line">            System.out.println(o1);</div><div class="line">        &#125;);</div><div class="line">        System.out.println(<span class="string">"------WeakReference--------"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">strongReference</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">softReference</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"------softReference--------"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">            <span class="comment">//list.add(buff)</span></div><div class="line">            SoftReference softReference = <span class="keyword">new</span> SoftReference(buff);</div><div class="line">            list.add(softReference);</div><div class="line">        &#125;</div><div class="line">        list.forEach(o -&gt; &#123;</div><div class="line">            Object o1 = ((SoftReference) o).get();</div><div class="line">            System.out.println(o1);</div><div class="line">        &#125;);</div><div class="line">        System.out.println(<span class="string">"------softReference--------"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行以上代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在Android上使用 &lt;code&gt;Handler&lt;/code&gt; 引起了内存泄漏。从而认识了弱引用、软引用、虚引用。今天发现Kotlin 在Android 上Anko库里的&lt;code&gt;async&lt;/code&gt;, &lt;code&gt;uiThread&lt;/code&gt; 里面居然做了在异步执行过程中Activity销毁了uiThread则不会调用，防止内存泄漏。正是采用了弱引用，先温习一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Java随笔记录" scheme="http://lazy.github.io/categories/Java%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Java" scheme="http://lazy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>用 Handler 轻松实现专属Android定时器</title>
    <link href="http://lazy.github.io/2017/12/19/android/2017-12-19-handlerTaskTimer/"/>
    <id>http://lazy.github.io/2017/12/19/android/2017-12-19-handlerTaskTimer/</id>
    <published>2017-12-19T07:10:27.000Z</published>
    <updated>2017-12-26T14:39:58.555Z</updated>
    
    <content type="html"><![CDATA[<p>今年在项目中发现为了实现倒计时、时间段的延迟执行、时间段的轮询执行任务，都是采用Handler postDelayed(runnable,delayMillis). 等等，这有毛病？那你将实现以上功能时、代码大概如下。</p><a id="more"></a> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Handler handler = <span class="keyword">new</span> Handler()；</div><div class="line"><span class="keyword">int</span> countDown = <span class="number">30</span>;</div><div class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (countDown&gt;<span class="number">0</span>)&#123;</div><div class="line">                handler.postDelayed(r,<span class="number">1</span>);</div><div class="line">                countDown--;</div><div class="line">            &#125;</div><div class="line">        &#125;&#125;;</div><div class="line">handler.postDelayed(r,<span class="number">0</span>);</div></pre></td></tr></table></figure><p>上面的代码还算好，如果是以 <code>handleMessage</code>、<code>sendEmptyMessageDelayed</code> 再通过<code>removeMessages</code>/<code>removeCallbacks</code> 去取消，这样的代码一大堆、追踪代码时，跳来跳去的。</p><p>这时我就想到了RxJava 的好了，难道为了这要加入RxJava？</p><p>所以， RxJava 好在哪？就好在简洁，好在那把什么复杂逻辑都只是一条链式调用。</p><p>因此把上面代码封装一个 HandlerTaskTimer 工具类，大概伪编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerTaskTimer</span></span>&#123;</div><div class="line">    <span class="comment">//成员变量</span></div><div class="line">  Handler uiHandler;</div><div class="line"></div><div class="line">  <span class="comment">//因为要链式调用,顺带采用构建者模式初始化必要参数</span></div><div class="line">  <span class="function">Builder <span class="title">newBuilder</span><span class="params">()</span></span></div><div class="line">    class Builder&#123;</div><div class="line">      <span class="comment">//一段时间后执行</span></div><div class="line">        period(<span class="keyword">long</span> period, TimeUnit unit)</div><div class="line">         <span class="comment">/**</span></div><div class="line">         * <span class="doctag">@param</span> period       一段时间后执行</div><div class="line">         * <span class="doctag">@param</span> initialDelay 首次延迟执行时间</div><div class="line">         * <span class="doctag">@param</span> unit</div><div class="line">         * <span class="doctag">@return</span></div><div class="line">         */</div><div class="line">        period(<span class="keyword">long</span> period, <span class="keyword">long</span> initialDelay, TimeUnit unit)</div><div class="line">        <span class="comment">//首次延迟执行时间</span></div><div class="line">        initialDelay(<span class="keyword">long</span> period, TimeUnit unit) </div><div class="line">        <span class="comment">//takeWhile 倒计时Count  </span></div><div class="line">        takeWhile(<span class="keyword">long</span> takeWhile)</div><div class="line">        <span class="comment">//tag</span></div><div class="line">        tag(String tag)</div><div class="line">        <span class="comment">//任务执行完成CallBack</span></div><div class="line">        accept(Action action)  </div><div class="line">        <span class="comment">//倒计时回调  </span></div><div class="line">        accept(Consumer&lt;Long&gt; longConsumer)  </div><div class="line">        accept(Consumer&lt;Long&gt; longConsumer, Action action)</div><div class="line">        </div><div class="line">        <span class="comment">//倒计时模式任务</span></div><div class="line">        countDown() </div><div class="line">        <span class="comment">//循环模式任务</span></div><div class="line">        loopExecute() </div><div class="line">        <span class="comment">//延迟模式任务</span></div><div class="line">        delayExecute() </div><div class="line">        <span class="comment">//启动任务</span></div><div class="line">        start()</div><div class="line">        <span class="comment">//取消任务</span></div><div class="line">        cancel()</div><div class="line">        <span class="comment">//恢复任务</span></div><div class="line">        resume()</div><div class="line">        <span class="comment">//暂停任务</span></div><div class="line">        pause()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来就慢慢实现功能了，条条大路通罗马，也许你有更好的实现方式，以下是我本人的简单实现十分轻巧的定时任务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">HandlerTaskTimer.getInstance().newBuilder()</div><div class="line">               .tag(TAG_COUNTDOWN)</div><div class="line">               .period(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">               .takeWhile(LauncherActivity.DELAY_LAUNCH_DEFAULT)</div><div class="line">               .countDown()</div><div class="line">               .accept(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                       updateCancelLaunchButton(aLong);</div><div class="line">                   &#125;</div><div class="line">               &#125;, <span class="keyword">new</span> Action() &#123;</div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                       performLaunchButtonClick();</div><div class="line">                   &#125;</div><div class="line">               &#125;).start();</div></pre></td></tr></table></figure><p>哈哈，是不是好看多了！！代码不一一列出了，参照我👇 GitHub上的Demo 实现，还有Kotlin 的实现呢</p><p><a href="https://github.com/iflove/AndroidDeveloperTools" target="_blank" rel="external"><strong>AndroidDeveloperTools</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年在项目中发现为了实现倒计时、时间段的延迟执行、时间段的轮询执行任务，都是采用Handler postDelayed(runnable,delayMillis). 等等，这有毛病？那你将实现以上功能时、代码大概如下。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://lazy.github.io/categories/Android/"/>
    
    
      <category term="AndroidDevelop" scheme="http://lazy.github.io/tags/AndroidDevelop/"/>
    
  </entry>
  
  <entry>
    <title>My ToolsBox</title>
    <link href="http://lazy.github.io/2017/12/16/android/2017-12-16-toolsBox/"/>
    <id>http://lazy.github.io/2017/12/16/android/2017-12-16-toolsBox/</id>
    <published>2017-12-16T07:10:27.000Z</published>
    <updated>2017-12-26T14:40:59.355Z</updated>
    
    <content type="html"><![CDATA[<p>时间一长,掌握的工具越来越多,脑容量不够用了,便随笔记录. </p><a id="more"></a> <h1 id="adb"><a href="#adb" class="headerlink" title="adb"></a>adb</h1><p><a href="https://developer.android.com/studio/command-line/adb.html" target="_blank" rel="external">Android 调试桥</a></p><h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">SSH原理与运用-远程登录</a></p><p><a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">SSH keys (简体中文)</a>)</p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p><a href="https://book.git-scm.com/" target="_blank" rel="external">Git</a></p><p><a href="https://book.git-scm.com/docs" target="_blank" rel="external">Git Doc</a></p><p><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="external">git - 简易指南</a></p><p><a href="http://git.oschina.net/progit/" target="_blank" rel="external">Pro Git（中文版)</a></p><p><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解</a></p><h1 id="gitlab"><a href="#gitlab" class="headerlink" title="gitlab"></a>gitlab</h1><p><a href="https://about.gitlab.com/" target="_blank" rel="external">gitlab</a></p><h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p><a href="http://wowubuntu.com/markdown/#list" target="_blank" rel="external">Markdown 语法说明</a></p><h2 id="博客框架"><a href="#博客框架" class="headerlink" title="博客框架"></a>博客框架</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a></p><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">开始使用 - NexT 使用文档</a></p><p><a href="https://jekyllrb.com/" target="_blank" rel="external">Jekyll-Site</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间一长,掌握的工具越来越多,脑容量不够用了,便随笔记录. &lt;/p&gt;
    
    </summary>
    
      <category term="Android随笔记录" scheme="http://lazy.github.io/categories/Android%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="tools" scheme="http://lazy.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>搬瓦工VPS -简单搭建ShadowsocksR</title>
    <link href="http://lazy.github.io/2017/12/16/tools/Vps-Shadowsocks/"/>
    <id>http://lazy.github.io/2017/12/16/tools/Vps-Shadowsocks/</id>
    <published>2017-12-16T07:10:27.000Z</published>
    <updated>2017-12-26T14:38:28.474Z</updated>
    
    <content type="html"><![CDATA[<p> 最近买的Shadowsocks 账号都被封了。无奈只好花$28.19 USD买了个搬瓦工VPS,又简单搭建ShadowsocksR进行科学上网.<br><a id="more"></a> </p><h1 id="搬瓦工VPS"><a href="#搬瓦工VPS" class="headerlink" title="搬瓦工VPS"></a>搬瓦工VPS</h1><p><a href="http://banwagong.cn/" target="_blank" rel="external">搬瓦工VPS中文网_搬瓦工</a></p><p><a href="https://bwh1.net/index.php" target="_blank" rel="external">搬瓦工</a></p><h1 id="安装服务端ShadowsocksR"><a href="#安装服务端ShadowsocksR" class="headerlink" title="安装服务端ShadowsocksR"></a>安装服务端ShadowsocksR</h1><p>在这里不推荐搬瓦工后台一键安装,推荐用root用户登录执行一键安装脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</div><div class="line">chmod +x shadowsocksR.sh</div><div class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</div></pre></td></tr></table></figure><p><strong>卸载方法：</strong><br>使用 root 用户登录，运行命令：<code>./shadowsocksR.sh uninstall</code></p><p>安装完成后即已后台启动 ShadowsocksR ，运行：<code>/etc/init.d/shadowsocks status</code><br>可以查看 ShadowsocksR 进程是否已经启动。<br>本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。</p><p><strong>常用命令：</strong><br>启动：<code>/etc/init.d/shadowsocks start</code><br>停止：<code>/etc/init.d/shadowsocks stop</code><br>重启：<code>/etc/init.d/shadowsocks restart</code><br>状态：<code>/etc/init.d/shadowsocks status</code></p><p><strong>默认配置信息：</strong></p><p>配置文件路径：<code>/etc/shadowsocks.json</code></p><p>日志文件路径：<code>/var/log/shadowsocks.log</code></p><p>代码安装目录：<code>/usr/local/shadowsocks</code></p><p><strong>参考链接：</strong></p><p><a href="https://xyzardq.github.io/2017/03/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BAshadowsocks%E5%8F%8A%E4%BC%98%E5%8C%96/" target="_blank" rel="external">shadowsocksR 一键安装</a></p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>多端口配置、多用户配置.个人建议加密方式使用none或aes-256-cfb，协议定义插件auth_chain_a,混淆插件tls1.2_ticket_auth</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</div><div class="line">    &quot;server_ipv6&quot;:&quot;[::]&quot;,</div><div class="line">    &quot;local_port&quot;:1080,</div><div class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</div><div class="line">    &quot;port_password&quot;:&#123;</div><div class="line">    &quot;443&quot;:&quot;banwagong1234&quot;,</div><div class="line">    &quot;8989&quot;:&quot;banwagong1234&quot;</div><div class="line">&#125;,</div><div class="line">    &quot;timeout&quot;:120,</div><div class="line">    &quot;method&quot;:&quot;none&quot;,</div><div class="line">    &quot;protocol&quot;:&quot;auth_chain_a&quot;,</div><div class="line">    &quot;protocol_param&quot;:&quot;&quot;,</div><div class="line">    &quot;obfs&quot;:&quot;tls1.2_ticket_auth&quot;,</div><div class="line">    &quot;obfs_param&quot;:&quot;&quot;,</div><div class="line">    &quot;redirect&quot;:&quot;&quot;,</div><div class="line">    &quot;dns_ipv6&quot;:false,</div><div class="line">    &quot;fast_open&quot;:false,</div><div class="line">    &quot;workers&quot;:1</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>参考链接：</strong></p><p><a href="https://github.com/iMeiji/shadowsocks_install/blob/master/shadowsocksR-wiki/ShadowsocksR%20%E5%8D%8F%E8%AE%AE%E6%8F%92%E4%BB%B6%E6%96%87%E6%A1%A3.md" target="_blank" rel="external">ShadowsocksR 协议插件文档</a></p><h1 id="开启TCP-BBR拥塞控制算法"><a href="#开启TCP-BBR拥塞控制算法" class="headerlink" title="开启TCP BBR拥塞控制算法"></a>开启TCP BBR拥塞控制算法</h1><p><strong>参考链接：</strong></p><p><a href="https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95" target="_blank" rel="external">shadowsocksR 一键安装</a></p><h1 id="Crontab-定时任务"><a href="#Crontab-定时任务" class="headerlink" title="Crontab 定时任务"></a>Crontab 定时任务</h1><p>VPS centos 定时重启</p><h2 id="centos-下安装crontab"><a href="#centos-下安装crontab" class="headerlink" title="centos 下安装crontab"></a>centos 下安装crontab</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install crontab</div><div class="line">chkconfig crond on</div><div class="line">service crond start</div></pre></td></tr></table></figure><p>设置一下中国时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@host ~]# date -R; date +%z  </div><div class="line">Sat, 16 Dec 2017 01:41:29 -0500</div><div class="line">-0500</div><div class="line">[root@host ~]# cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</div></pre></td></tr></table></figure><p>查看任务：crontab -l</p><p>编辑任务：crontab -e</p><p>凌晨5点重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 5  * * * /sbin/shutdown -r now</div></pre></td></tr></table></figure><p>查看上一次情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">last</div></pre></td></tr></table></figure><p><strong>参考链接：</strong></p><p><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="external">crontab 定时任务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 最近买的Shadowsocks 账号都被封了。无奈只好花$28.19 USD买了个搬瓦工VPS,又简单搭建ShadowsocksR进行科学上网.&lt;br&gt;
    
    </summary>
    
      <category term="科学上网" scheme="http://lazy.github.io/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="Shadowsocks" scheme="http://lazy.github.io/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>记录博客好文</title>
    <link href="http://lazy.github.io/2017/11/01/blog/Blog-like/"/>
    <id>http://lazy.github.io/2017/11/01/blog/Blog-like/</id>
    <published>2017-11-01T14:56:35.235Z</published>
    <updated>2018-01-15T15:41:37.881Z</updated>
    
    <content type="html"><![CDATA[<p>收集博客好文</p><a id="more"></a> <h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><p><a href="https://mp.weixin.qq.com/s/RzZ8rhYWZQ9ncdci1cRvJA" target="_blank" rel="external">Android Studio 调试技巧</a></p><h1 id="Android-技术进阶"><a href="#Android-技术进阶" class="headerlink" title="Android 技术进阶"></a>Android 技术进阶</h1><p><a href="https://juejin.im/post/59b541795188257e8822dfd9" target="_blank" rel="external">Android 开发者该如何进阶？</a></p><h2 id="Android-事件"><a href="#Android-事件" class="headerlink" title="Android 事件"></a>Android 事件</h2><p><a href="https://user-gold-cdn.xitu.io/2017/9/10/9165b4353b1d09b379b69e4e9ba90f0f?imageView2/0/w/1280/h/960" target="_blank" rel="external">Android 事件分发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集博客好文&lt;/p&gt;
    
    </summary>
    
      <category term="博客好文" scheme="http://lazy.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%A5%BD%E6%96%87/"/>
    
    
      <category term="Android&amp;Java" scheme="http://lazy.github.io/tags/Android-Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux、Mac下GBK与UTF8编码文件的批量转换</title>
    <link href="http://lazy.github.io/2017/10/10/tools/iconv-shell/"/>
    <id>http://lazy.github.io/2017/10/10/tools/iconv-shell/</id>
    <published>2017-10-10T09:22:27.000Z</published>
    <updated>2018-01-09T14:52:21.885Z</updated>
    
    <content type="html"><![CDATA[<p>使用 iconv 进行批量转码脚本工具</p><a id="more"></a> <h1 id="Linux、Mac下GBK与UTF8编码文件的批量转换脚本"><a href="#Linux、Mac下GBK与UTF8编码文件的批量转换脚本" class="headerlink" title="Linux、Mac下GBK与UTF8编码文件的批量转换脚本"></a>Linux、Mac下GBK与UTF8编码文件的批量转换脚本</h1><p>使用 iconv 进行批量转码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">FILES=$(find . -type f -name <span class="string">'*.java'</span>)</div><div class="line"><span class="keyword">for</span> f <span class="keyword">in</span> <span class="variable">$FILES</span></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> <span class="built_in">test</span> <span class="_">-f</span> <span class="variable">$f</span>; <span class="keyword">then</span></div><div class="line">        CHARSET=<span class="string">"<span class="variable">$( file --mime-encoding "$f"| awk -F ": " '&#123;print $2&#125;')</span>"</span></div><div class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$CHARSET</span>"</span> != utf-8 ]; <span class="keyword">then</span></div><div class="line">            sh -c <span class="string">"iconv -f <span class="variable">$CHARSET</span> -t UTF-8 <span class="variable">$f</span> &gt; <span class="variable">$f</span>.temp"</span></div><div class="line">            mv <span class="_">-f</span> <span class="string">"<span class="variable">$f</span>.temp"</span> <span class="variable">$f</span></div><div class="line">        <span class="keyword">fi</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"\nSkipping <span class="variable">$f</span> - it's a regular file"</span>;</div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><p>终端运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh to.sh</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 iconv 进行批量转码脚本工具&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://lazy.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="脚本工具" scheme="http://lazy.github.io/tags/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>记录Android</title>
    <link href="http://lazy.github.io/2017/09/23/android/Android%20NOTE/"/>
    <id>http://lazy.github.io/2017/09/23/android/Android NOTE/</id>
    <published>2017-09-23T03:21:46.000Z</published>
    <updated>2018-01-15T15:42:27.306Z</updated>
    
    <content type="html"><![CDATA[<p>记录Android 点滴</p><a id="more"></a> <h2 id="AppCompat-Theme-Fullscreen"><a href="#AppCompat-Theme-Fullscreen" class="headerlink" title="AppCompat Theme Fullscreen"></a>AppCompat Theme Fullscreen</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar.FullScreen"</span> <span class="attr">parent</span>=<span class="string">"@style/Theme.AppCompat.Light"</span>&gt;</span><span class="xml"></span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"windowNoTitle"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"windowActionBar"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowFullscreen"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowContentOverlay"</span>&gt;</span>@null<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="Actiivity-动画"><a href="#Actiivity-动画" class="headerlink" title="Actiivity 动画"></a>Actiivity 动画</h2><p>overridePendingTransition方法需要在startAtivity方法或者是finish方法调用之后立即执行</p><h3 id="Andoid-studio-编码设置"><a href="#Andoid-studio-编码设置" class="headerlink" title="Andoid studio 编码设置"></a>Andoid studio 编码设置</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compileOptions &#123;</div><div class="line">    encoding <span class="string">"GBK"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">     useLibrary <span class="string">'org.apache.http.legacy'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="adb"><a href="#adb" class="headerlink" title="adb"></a>adb</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb shell getprop</div><div class="line">adb shell getprop ro.product.cpu.abi</div></pre></td></tr></table></figure><h2 id="camera"><a href="#camera" class="headerlink" title="camera"></a>camera</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hw.camera=yes</div><div class="line">hw.camera.back: webcam0</div><div class="line">hw.camera.front: webcam0</div></pre></td></tr></table></figure><h2 id="gradle-build-error"><a href="#gradle-build-error" class="headerlink" title="gradle build error"></a>gradle build error</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Unsupported major.minor version <span class="number">52.0</span></div><div class="line"></div><div class="line">use jdk <span class="number">8</span></div></pre></td></tr></table></figure><h2 id="python-环境工具"><a href="#python-环境工具" class="headerlink" title="python 环境工具"></a>python 环境工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">virtualenv -p python3 test</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Android 点滴&lt;/p&gt;
    
    </summary>
    
      <category term="Android随笔记录" scheme="http://lazy.github.io/categories/Android%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Android" scheme="http://lazy.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AndroidJUnit4 用法</title>
    <link href="http://lazy.github.io/2017/08/30/android/AndroidJUnit4/"/>
    <id>http://lazy.github.io/2017/08/30/android/AndroidJUnit4/</id>
    <published>2017-08-30T02:05:07.000Z</published>
    <updated>2018-01-15T15:15:26.697Z</updated>
    
    <content type="html"><![CDATA[<p>AndroidJUnit4 是一个让 <a href="http://www.oschina.net/p/junit" target="_blank" rel="external">JUnit</a> 4 可以直接运行在 Android 设备上的开源工具。</p><a id="more"></a> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(AndroidJUnit4.class)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span></div></pre></td></tr></table></figure><ul><li>@Test：把一个方法标记为测试方法</li><li>@Before：每一个测试方法执行前自动调用一次</li><li>@After：每一个测试方法执行完自动调用一次</li><li>@BeforeClass：所有测试方法执行前执行一次，在测试类还没有实例化就已经被加载，所以用static修饰</li><li>@AfterClass：所有测试方法执行完执行一次，在测试类还没有实例化就已经被加载，所以用static修饰</li><li>@Ignore：暂不执行该测试方法</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FixMethodOrder(MethodSorters.NAME_ASCENDING)</span>  <span class="comment">//给我按name顺序执行</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AndroidJUnit4 是一个让 &lt;a href=&quot;http://www.oschina.net/p/junit&quot;&gt;JUnit&lt;/a&gt; 4 可以直接运行在 Android 设备上的开源工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Android随笔记录" scheme="http://lazy.github.io/categories/Android%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="AndroidJUnit" scheme="http://lazy.github.io/tags/AndroidJUnit/"/>
    
  </entry>
  
  <entry>
    <title>My Git Note</title>
    <link href="http://lazy.github.io/2017/08/23/git/git-note/"/>
    <id>http://lazy.github.io/2017/08/23/git/git-note/</id>
    <published>2017-08-23T02:50:04.000Z</published>
    <updated>2018-01-15T15:04:51.477Z</updated>
    
    <content type="html"><![CDATA[<p>git 常用命令备忘录</p><a id="more"></a> <h2 id="git-提交时的用户和邮箱"><a href="#git-提交时的用户和邮箱" class="headerlink" title="git 提交时的用户和邮箱"></a>git 提交时的用户和邮箱</h2><p>查看全局的设置中的用户和邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name </div><div class="line">git config --global user.email</div></pre></td></tr></table></figure><p>查看当前的设置中的用户和邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config user.name </div><div class="line">git config user.email</div></pre></td></tr></table></figure><p>要是想修改的话直接在查看命令后加要修改的值如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config user.name &quot;YourName&quot;</div></pre></td></tr></table></figure><h2 id="git-stash恢复"><a href="#git-stash恢复" class="headerlink" title="git stash恢复"></a>git stash恢复</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git stash pop stash@&#123;num&#125;</div></pre></td></tr></table></figure><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p><code>git remote</code>命令列出所有远程主机，使用<code>-v</code>选项，可以参看远程主机的网址</p><p><code>git remote add</code>命令用于添加远程主机。</p><p><code>git remote rm</code>命令用于删除远程主机。</p><p><code>git remote rename</code>命令用于远程主机的改名。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 常用命令备忘录&lt;/p&gt;
    
    </summary>
    
      <category term="Git随笔记录" scheme="http://lazy.github.io/categories/Git%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="git" scheme="http://lazy.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>基于 android-x86-4.4-r5 分支编译构建live cdrom iso映像</title>
    <link href="http://lazy.github.io/2017/06/26/asop/android-x86-make-iso/"/>
    <id>http://lazy.github.io/2017/06/26/asop/android-x86-make-iso/</id>
    <published>2017-06-26T13:30:53.000Z</published>
    <updated>2018-02-24T16:04:10.873Z</updated>
    
    <content type="html"><![CDATA[<p>工作需要, 基于 android-x86-4.4-r5 分支编译构建live cdrom iso映像</p><a id="more"></a> <h2 id="在Android-x86树上选择分支"><a href="#在Android-x86树上选择分支" class="headerlink" title="在Android-x86树上选择分支"></a>在Android-x86树上选择分支</h2><p>这里我选择 <code>android-x86-4.4-r5</code> 分支</p><h2 id="建立一个Linux构建环境"><a href="#建立一个Linux构建环境" class="headerlink" title="建立一个Linux构建环境"></a>建立一个Linux构建环境</h2><blockquote><p>Android x86-4.4-r5版本在最近版本的Ubuntu LTS（16.04）64位上进行测试，具有所需的构建工具。<br>在下载和构建Android-x86源代码之前，请确保您的系统满足以下要求：</p></blockquote><ul><li>至少100GB的可用磁盘空间</li><li>Python 2.6 - 2.7，你可以从python.org下载。</li><li>GNU Make 3.81 - 3.82，你可以从gnu.org下载，</li><li>在Android开源项目（AOSP）中构建Android的4.4分支需要JDK 6</li><li>Git 1.7或更新。你可以在git-scm.com找到它。</li></ul><p><strong>请注意 :</strong> 对于<strong>kitkat-x86</strong>或更高版本，64位环境是<strong>必需</strong>的。</p><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><ol><li>从<a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html#jdk-6u31-oth-JPR" target="_blank" rel="external">oracle jdk-6u31</a>下载Java JDK 。</li><li>点击<strong>接受许可协议</strong></li><li>点击<strong>jdk-6u31-linux-x64.bin</strong></li><li>用您的Oracle帐户登录到Oracle.com</li><li>将JDK下载到您的<strong>〜/ Downloads</strong>目录</li><li>下载后，打开一个终端，然后输入以下命令。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ~/Downloads</div><div class="line">chmod +x jdk-6u31-linux-x64.bin</div><div class="line">./jdk-6u31-linux-x64.bin</div></pre></td></tr></table></figure><p>根据生成jdk 目录配置环境变量, 执行命令: <code>vi ~/.bashrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> JAVA_HOME=/home/jfn/androidDevelop/jdk1.6.0_31 <span class="comment">#jdk的主目录</span></div><div class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</div><div class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$CLASSPATH</span></div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$ANDROID_SDK</span>/platform-tools:<span class="variable">$PATH</span></div></pre></td></tr></table></figure><p>使jdk环境变量生效, 执行 <code>source ~/.bashrc</code></p><p>查看jdk版本, 执行 <code>java -version、javac –version</code></p><h4 id="安装make-3-81"><a href="#安装make-3-81" class="headerlink" title="安装make-3.81"></a>安装make-3.81</h4><p>1.下载并解压make-3.81.tar.bz2，进入make-3.81目录并执行 <code>./configure</code></p><p>2.执行完后make-3.81目录会多出一个build.sh文件，执行<code>./build.sh</code> 即可得到make文件</p><p>3.验证编译出来的make是不是我们想要的3.81版本。<code>make -v</code></p><p>4.替换系统原有的make。（记得备份原有文件。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/bin/</div><div class="line">sudo mv ./make ./make.backup</div><div class="line">mv ~/make-3.81/make ./</div></pre></td></tr></table></figure><h4 id="安装所需的软件包（Ubuntu-16-04）"><a href="#安装所需的软件包（Ubuntu-16-04）" class="headerlink" title="安装所需的软件包（Ubuntu 16.04）"></a><strong>安装所需的软件包</strong>（Ubuntu 16.04）</h4><p>您将需要一个64位版本的Ubuntu。推荐Ubuntu 16.04。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential \</div><div class="line">   zip curl zlib1g-dev gcc-multilib g ++  -  multilib libc6-dev-i386 \</div><div class="line">   lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \</div><div class="line">   libgl1-mesa-dev libxml2-utils xsltproc unzip squashfs-tools python-mako</div></pre></td></tr></table></figure><p>你还需要安装OpenSSL相应软件包。OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install apache2      ##安装Apache</div><div class="line">sudo apt-get install openssl      ##安装openssl</div><div class="line">sudo apt-get install libssl-dev    ##安装openssl开发库</div><div class="line">sudo apt-get install bless      ##编辑器使用 bless 十六进制编辑器,需预先安装</div></pre></td></tr></table></figure><h2 id="获取-Android-源码"><a href="#获取-Android-源码" class="headerlink" title="获取 Android 源码"></a>获取 Android 源码</h2><p><a href="http://www.android-x86.org/" target="_blank" rel="external">Android x86 开源项目</a> 网站提供了，获取方法如下:</p><p>​    <a href="http://www.android-x86.org/getsourcecode" target="_blank" rel="external">http://www.android-x86.org/getsourcecode</a></p><p>下面介绍了 <code>repo</code> 工具的安装,以及基本用法。</p><h3 id="Installing-Repo"><a href="#Installing-Repo" class="headerlink" title="Installing Repo"></a>Installing Repo</h3><p>1.确保您的主目录中有一个bin /目录，并将其包含在您的路径中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir ~/bin</div><div class="line">PATH=~/bin:$PATH</div></pre></td></tr></table></figure><p>2.下载Repo工具并确保它是可执行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div><div class="line">chmod a+x ~/bin/repo</div></pre></td></tr></table></figure><p>3.通过 <code>repo init</code> 将当前目录初始化为工作区,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir android-x86</div><div class="line">cd android-x86</div><div class="line">repo init -u git://git.osdn.net/gitroot/android-x86/manifest -b android-x86-4.4-r5</div></pre></td></tr></table></figure><p>NOTE:由于网络原因国内的访问不了google的仓库，需要把 REPO_URL = ‘<a href="https://gerrit.googlesource.com/git-repo&#39;%E6%94%B9%E4%B8%BA" target="_blank" rel="external">https://gerrit.googlesource.com/git-repo’ 改为</a> REPO_URL = ‘git://git.omapzoom.org/git-repo.git’ 。另外还需科学上网download 源码，这里推荐</p><p><code>Shadowsocks-Qt5</code> , 配置好网络代理后，还需要设置git 的代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global https.proxy https://127.0.0.1:1080</div></pre></td></tr></table></figure><p>4.使用身份验证</p><p>注意: 默认情况下，访问 Android 源代码均为匿名操作。为了防止服务器被过度使用，每个 IP 地址都有一个相关联的配额。正常来说是下载源码不成功的，请参考官方ASOP  <a href="https://source.android.com/setup/downloading" target="_blank" rel="external">下载源代码</a></p><p>5.repo init 完成</p><p>成功初始化后,会在当前工作目录下创建 <code>.repo</code> 文件夹（隐藏的）,并从 <code>-u</code> 参数所指定的repository 下载一个 <code>mainffest.xml</code> 文件到<code>.repo</code> 文件夹。清单文件定义了Android源代码中所有的git项目的清单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"aosp"</span></span></div><div class="line">           <span class="attr">fetch</span>=<span class="string">".."</span> /&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">default</span> <span class="attr">revision</span>=<span class="string">"refs/tags/android-7.1.1_r28"</span></span></div><div class="line">           <span class="attr">remote</span>=<span class="string">"aosp"</span></div><div class="line">           <span class="attr">sync-j</span>=<span class="string">"4"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">"build"</span> <span class="attr">name</span>=<span class="string">"platform/build"</span> <span class="attr">groups</span>=<span class="string">"pdk,tradefed"</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">copyfile</span> <span class="attr">src</span>=<span class="string">"core/root.mk"</span> <span class="attr">dest</span>=<span class="string">"Makefile"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">project</span>&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure><p>显而易见，其中每个 project 项都代表一个 git 项目，<code>name</code> 属性指定了git 项目名称，<code>path</code>属性指定了git 项目将被下载到哪个文件中。<code>revision</code> 指定了那个分支的代码。通过 <code>repo sync</code> 命令便可以下载代码。<code>repo sync</code> 可以接受 -j 参数进行多线程的代码下载以提高下载速度。例：<code>repo sync -j4</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repo sync platform/frameworks/base</div></pre></td></tr></table></figure><p>repo sync 也可以接受 git 项目名称作为参数单独下载这个项目的代码。</p><p>6.从Android 源代码树默认清单中指定的代码库下载到工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repo sync</div></pre></td></tr></table></figure><h2 id="编译Android源码"><a href="#编译Android源码" class="headerlink" title="编译Android源码"></a>编译Android源码</h2><h3 id="直接构建一个live-cdrom-iso映像"><a href="#直接构建一个live-cdrom-iso映像" class="headerlink" title="直接构建一个live cdrom iso映像"></a>直接构建一个live cdrom iso映像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make iso_img TARGET_PRODUCT = android_x86</div></pre></td></tr></table></figure><p>注意: android-x86-4.4-r5 分支 请必须直接按上构建iso 映像</p><h3 id="编译要求"><a href="#编译要求" class="headerlink" title="编译要求"></a>编译要求</h3><p>下载和编译 Android 源代码之前，请先确保您的系统符合官方要求。请参阅<a href="https://source.android.com/source/requirements" target="_blank" rel="external">requirements</a></p><h3 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h3><p>编译Android 源码总不会一帆风顺的。根据错误信息提示，少了什么就安装什么。比如：<code>/bin/bash: xmllint: 未找到命令</code>   就执行<code>sudo apt-get install libxml2</code> 即可，c++ 头文件、Python module 也是如此。另外多查查资料。</p><h4 id="hybrid-v35-nodebug-pcoem-6-30-223-271-tar-gz-文件缺失错误"><a href="#hybrid-v35-nodebug-pcoem-6-30-223-271-tar-gz-文件缺失错误" class="headerlink" title="hybrid-v35-nodebug-pcoem-6_30_223_271.tar.gz  文件缺失错误"></a>hybrid-v35-nodebug-pcoem-6_30_223_271.tar.gz  文件缺失错误</h4><p>错误日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">gzip: stdin: unexpected end of file</div><div class="line">tar: Child returned status 1</div><div class="line">tar: Error is not recoverable: exiting now</div><div class="line">make: *** [kernel/drivers/net/wireless/wl/Makefile] Error 2</div><div class="line">make: *** 正在等待未完成的任务....</div><div class="line">make[2]: Entering directory `/home/jfn/androidDevelop/out/target/product/x86/obj/kernel<span class="string">'</span></div><div class="line">  HOSTCC  scripts/basic/fixdep</div><div class="line">  GEN     ./Makefile</div><div class="line">  HOSTCC  scripts/kconfig/conf.o</div><div class="line">  SHIPPED scripts/kconfig/zconf.tab.c</div><div class="line">  SHIPPED scripts/kconfig/zconf.lex.c</div><div class="line">  SHIPPED scripts/kconfig/zconf.hash.c</div><div class="line">  HOSTCC  scripts/kconfig/zconf.tab.o</div><div class="line">  HOSTLD  scripts/kconfig/conf</div><div class="line">scripts/kconfig/conf --olddefconfig Kconfig</div><div class="line">.config:6553:warning: override: reassigning to symbol ANDROID_LOGGER</div><div class="line">.config:6554:warning: override: reassigning to symbol ANDROID_INTF_ALARM_DEV</div><div class="line">#</div><div class="line"># configuration written to .config</div><div class="line">#</div><div class="line">make[2]: Leaving directory `/home/jfn/androidDevelop/out/target/product/x86/obj/kernel'</div><div class="line">make[1]: Leaving directory `/home/jfn/androidDevelop/kernel<span class="string">'</span></div></pre></td></tr></table></figure><p>由 tar: Error ,而且 /kernel/drivers/net/wireless/wl 下的hybrid-v35-nodebug-pcoem-6_30_223_271.tar.gz 文件长度为0. 打开build.mk 发现了通过 <a href="http://www.broadcom.com/docs/linux_sta/" target="_blank" rel="external">http://www.broadcom.com/docs/linux_sta/</a> 网站去下载的，而这个链接过期了</p><p>下载 <a href="https://pkgs.rpmfusion.org/repo/pkgs/nonfree/broadcom-wl/hybrid-v35-nodebug-pcoem-6_30_223_271.tar.gz/4e75f4cb7d87f690f9659ffc478495f0/" target="_blank" rel="external">hybrid-v35-nodebug-pcoem-6_30_223_271.tar.gz </a> 文件放进去再编译就好了。</p><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>生成系统镜像在下面目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">out/target/product/x86/android_x86.iso</div></pre></td></tr></table></figure><h2 id="在-Android-Studio中导入-Android-源码"><a href="#在-Android-Studio中导入-Android-源码" class="headerlink" title="在 Android Studio中导入 Android 源码"></a>在 Android Studio中导入 Android 源码</h2><p>在 <code>/development/ide</code> 下分别有eclipse/emacs/intellij 这3个ide 的配置文件。因为源码文件十分多,强烈建议as增加jvm 内存大小。</p><h4 id="生成导入AS所需配置文件-ipr"><a href="#生成导入AS所需配置文件-ipr" class="headerlink" title="生成导入AS所需配置文件(*.ipr)"></a>生成导入AS所需配置文件(*.ipr)</h4><ul><li><p>编译源码(为了确保生成了.java文件，如R.java；如果编译过，则无需再次编译)</p></li><li><p>检查out/host/linux-x86/framework/目录下是否有idegen.jar</p></li></ul><p>如果idegen.jar不存在, 执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mmm development/tools/idegen/</div><div class="line">development/tools/idegen/idegen.sh</div></pre></td></tr></table></figure><p>等待出现类似下面的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Read excludes: 5ms</div><div class="line">Traversed tree: 44078ms</div></pre></td></tr></table></figure><p>这时会在源码的根目录下生成android.ipr和android.iml两个IntelliJ IDEA(AS是基于IntelliJ IDEA社区版开发的)的配置文件.</p><p>Tips：AS在导入代码时比较慢，建议先修改android.iml，将自己用不到的代码exclude出去.可以仿照过滤.repo文件夹的语法,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/.repo&quot; /&gt;</div><div class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/abi&quot; /&gt;</div><div class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/art&quot; /&gt;</div><div class="line">...</div></pre></td></tr></table></figure><p>还可以通过as 的module settings - dependents 删除掉所有不需要的module-library项</p><p>这样在导入时就会跳过abi和art文件夹.过滤的越多，AS的处理速度就会越快.最后在AS中打开源码根目录下新生成的android.ipr</p><h4 id="解决源码中跳转错误问题"><a href="#解决源码中跳转错误问题" class="headerlink" title="解决源码中跳转错误问题"></a>解决源码中跳转错误问题</h4><p>要为当前工程设置正确的SDK和JDK，需要Android API 19 Platform，jdk 则无所谓，因为libcore 目录下包括了jdk 的源码。添加一个jdk 接着把classpath 所有项remove 掉，接着Android API 19 Platform 选择空的jdk.如下图<br><img src="http://img.blog.csdn.net/20180207145631611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ1NETm5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="步骤1"></p><p>点击Project<br><img src="http://img.blog.csdn.net/20180207145747921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ1NETm5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="步骤2"></p><p>点击Modules, 选择相应的代码模块，比如frameworks、packages 等源码目录，且把它们移动到最前优先从这两个文件夹下查找，而不是在Android.jar中查找<br><img src="http://img.blog.csdn.net/20180207145838877?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ1NETm5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>NOTE: Empty Library 不要紧的。</p><h4 id="DEBUG源码"><a href="#DEBUG源码" class="headerlink" title="DEBUG源码"></a>DEBUG源码</h4><p>在’Modules’中添加’Android Framework’来让AS将它作为一个Android工程，从而方便我们调试代码.<br><img src="http://img.blog.csdn.net/20180207150331651?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ1NETm5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>在代码中加断点，然后选择’Run’-&gt;’Attach debugger to Android process’或者直接点击ToolBar 上的Attach debugger图标。在弹出的选择进程(Choose Process)对话框中，勾选显示所有进程，选择要DEBUG的代码所在的进程，点击OK即可.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作需要, 基于 android-x86-4.4-r5 分支编译构建live cdrom iso映像&lt;/p&gt;
    
    </summary>
    
      <category term="Android源代码学习" scheme="http://lazy.github.io/categories/Android%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android x86" scheme="http://lazy.github.io/tags/Android-x86/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Android开篇之Android源代码编译及调试</title>
    <link href="http://lazy.github.io/2017/06/26/asop/android-open-source/"/>
    <id>http://lazy.github.io/2017/06/26/asop/android-open-source/</id>
    <published>2017-06-26T13:30:53.000Z</published>
    <updated>2018-02-24T16:06:12.461Z</updated>
    
    <content type="html"><![CDATA[<p>为了学习Android 源码，在Mac 下编译Android源码，Android Studio 下调试。</p><a id="more"></a> <h2 id="获取-Android-源码"><a href="#获取-Android-源码" class="headerlink" title="获取 Android 源码"></a>获取 Android 源码</h2><p>谷歌官方提供了<a href="https://source.android.com/" target="_blank" rel="external">Android 开源项目(简称AOSP)</a> 网站，获取方法如下:</p><p>​    <a href="https://source.android.com/setup/downloading" target="_blank" rel="external">https://source.android.com/setup/downloading</a></p><p>这个页面介绍了 <code>repo</code> 工具的安装,以及基本用法。</p><h2 id="Installing-Repo"><a href="#Installing-Repo" class="headerlink" title="Installing Repo"></a>Installing Repo</h2><p>1.确保您的主目录中有一个bin /目录，并将其包含在您的路径中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir ~/bin</div><div class="line">PATH=~/bin:$PATH</div></pre></td></tr></table></figure><p>2.下载Repo工具并确保它是可执行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div><div class="line">chmod a+x ~/bin/repo</div></pre></td></tr></table></figure><p>3.通过 <code>repo init</code> 将当前目录初始化为工作区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repo init -u &lt;repository 地址&gt; -b &lt;分支名称&gt;</div></pre></td></tr></table></figure><p>成功初始化后,会在当前工作目录下创建 <code>.repo</code> 文件夹（隐藏的）,并从 <code>-u</code> 参数所指定的repository 下载一个 <code>mainffest.xml</code> 文件到<code>.repo</code> 文件夹。清单文件定义了Android源代码中所有的git项目的清单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"aosp"</span></span></div><div class="line">           <span class="attr">fetch</span>=<span class="string">".."</span> /&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">default</span> <span class="attr">revision</span>=<span class="string">"refs/tags/android-7.1.1_r28"</span></span></div><div class="line">           <span class="attr">remote</span>=<span class="string">"aosp"</span></div><div class="line">           <span class="attr">sync-j</span>=<span class="string">"4"</span> /&gt;</div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">"build"</span> <span class="attr">name</span>=<span class="string">"platform/build"</span> <span class="attr">groups</span>=<span class="string">"pdk,tradefed"</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">copyfile</span> <span class="attr">src</span>=<span class="string">"core/root.mk"</span> <span class="attr">dest</span>=<span class="string">"Makefile"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">project</span>&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure><p>显而易见，其中每个 project 项都代表一个 git 项目，<code>name</code> 属性指定了git 项目名称，<code>path</code>属性指定了git 项目将被下载到哪个文件中。<code>revision</code> 指定了那个分支的代码。通过 <code>repo sync</code> 命令便可以下载代码。<code>repo sync</code> 可以接受 -j 参数进行多线程的代码下载以提高下载速度。例：<code>repo sync -j4</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repo sync platform/frameworks/base</div></pre></td></tr></table></figure><p>repo sync 也可以接受 git 项目名称作为参数单独下载这个项目的代码。</p><h3 id="在线阅读Android-源码"><a href="#在线阅读Android-源码" class="headerlink" title="在线阅读Android 源码"></a>在线阅读Android 源码</h3><p>AndroidXRef(<a href="http://androidxref.com/" target="_blank" rel="external">http://androidxref.com/</a>)项目提供 Android 源码的交叉索引，可以快速的搜索符合特定条件的 Android 源代码，后台是基于 OpenGrok 引擎，OpenGrok是一个快速，便于使用的源码搜索引擎与对照引擎，它能够帮助我们快速的搜索、定位、对照代码树。AndroidXRef 提供了完整的 Android kernel源码的索引。在 AndroidXRef 主页的右侧显示了可用的源码版本。</p><h2 id="编译Android源码"><a href="#编译Android源码" class="headerlink" title="编译Android源码"></a>编译Android源码</h2><h3 id="搭建编译环境"><a href="#搭建编译环境" class="headerlink" title="搭建编译环境"></a>搭建编译环境</h3><p>aosp 官网上介绍如何设置您的本地工作环境来构建Android源文件。您将需要使用Linux或Mac OS。比如我用Mac 就可以参考<a href="https://source.android.com/source/initializing#setting-up-a-mac-os-x-build-environment" target="_blank" rel="external">Mac 编译环境</a> 进行配置。</p><p>简单来说，一个创建大小写敏感的磁盘映像来装源码，Android 6.0的代码大约需要50GB，编译后达70多GB。</p><p>1.创建磁盘空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hdiutil create -type SPARSE -fs &apos;Case-sensitive Journaled HFS+&apos; -size 50g ~/android.dmg</div></pre></td></tr></table></figure></p><p>2.调整磁盘空间的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hdiutil resize -size 85g ~/android.dmg.sparseimage</div></pre></td></tr></table></figure></p><p>3.挂载映像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function mountAsop &#123; hdiutil attach /Volumes/Mac/MySourceFiles/aosp/android.dmg.sparseimage -mountpoint /Volumes/android; &#125;</div><div class="line">function umountAsop() &#123; hdiutil detach /Volumes/android; &#125;</div></pre></td></tr></table></figure></p><h3 id="设置文件同时打开数量"><a href="#设置文件同时打开数量" class="headerlink" title="设置文件同时打开数量"></a>设置文件同时打开数量</h3><p>在Mac中，默认的文件同时打开数实在太低，一个高速并行的编译进程运行时可能会遇到瓶颈。（注：Mac上<a href="https://link.jianshu.com?t=http://unix.stackexchange.com/questions/36841/why-is-number-of-open-files-limited-in-linux" target="_blank" rel="external">限制最大打开文件数的原因</a>是每打开一个文件，系统都需要内存来管理它们，内存是有限的资源）<br>为了增加最大文件打开数量，在~/.bash_profile中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 设置文件打开数量为1024</div><div class="line">ulimit -S -n 1024</div></pre></td></tr></table></figure><h3 id="编译要求"><a href="#编译要求" class="headerlink" title="编译要求"></a>编译要求</h3><p>下载和编译 Android 源代码之前，请先确保您的系统符合官方要求。请参阅<a href="https://source.android.com/source/requirements" target="_blank" rel="external">requirements</a></p><h3 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h3><p>开始编译Android 源码，请参阅<a href="https://source.android.com/setup/building" target="_blank" rel="external">Preparing to Build</a> 。总结一下，其步骤如下：</p><ol><li>执行 <code>source build/envsetup.sh</code> or <code>. build/envsetup.sh</code> ，将初始化Android 的编译环境，并声明了一系列方便操作源代码的bash函数，如 mmm、mm、cgrep、jgrep 等。</li><li>执行 <code>lunch + buildType</code>  设置即将编译的项目及类型 or <code>lunch</code> 再选择编译的项目及类型。</li><li>执行 <code>make -j4</code> ，启动4个线程进行编译，编译产物都会存储在Android 源代码根目录下的out 文件夹中。</li></ol><h3 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h3><p>编译Android 源码总不会一帆风顺的。根据错误信息提示，少了什么就安装什么。比如：<code>/bin/bash: xmllint: 未找到命令</code>   就执行<code>brew install libxml2</code> 即可，c++ 头文件也是如此。另外多查查资料。</p><h2 id="在-IDE-中导入-Android-源码"><a href="#在-IDE-中导入-Android-源码" class="headerlink" title="在 IDE 中导入 Android 源码"></a>在 IDE 中导入 Android 源码</h2><p>在 <code>/development/ide</code> 下分别有eclipse/emacs/intellij 这3个ide 的配置文件</p><h3 id="将Android-源码导入Eclipse"><a href="#将Android-源码导入Eclipse" class="headerlink" title="将Android 源码导入Eclipse"></a>将Android 源码导入Eclipse</h3><p>首先 <code>\development\ide\eclipse\.classpath</code> 文件复制到Android源码根目录下，因为源码文件十分多,强烈建议eclipse、intellij 增加jvm 内存大小。 可修改<code>.classpath</code> 文件指定 Eclipse 导入那些代码，导入Android源码只需要new Java Project （不是Android project）选择从已存在的工程导入，定位到Android源码的目录进行导入即可。</p><h3 id="在-Android-Studio中导入-Android-源码"><a href="#在-Android-Studio中导入-Android-源码" class="headerlink" title="在 Android Studio中导入 Android 源码"></a>在 Android Studio中导入 Android 源码</h3><p>在 <code>/development/ide</code> 下分别有eclipse/emacs/intellij 这3个ide 的配置文件。因为源码文件十分多,强烈建议as增加jvm 内存大小。</p><h4 id="生成导入AS所需配置文件-ipr"><a href="#生成导入AS所需配置文件-ipr" class="headerlink" title="生成导入AS所需配置文件(*.ipr)"></a>生成导入AS所需配置文件(*.ipr)</h4><ul><li><p>编译源码(为了确保生成了.java文件，如R.java；如果编译过，则无需再次编译)</p></li><li><p>检查out/host/linux-x86/framework/目录下是否有idegen.jar</p></li></ul><p>如果idegen.jar不存在, 执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mmm development/tools/idegen/</div><div class="line">development/tools/idegen/idegen.sh</div></pre></td></tr></table></figure><p>等待出现类似下面的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Read excludes: 5ms</div><div class="line">Traversed tree: 44078ms</div></pre></td></tr></table></figure><p>这时会在源码的根目录下生成android.ipr和android.iml两个IntelliJ IDEA(AS是基于IntelliJ IDEA社区版开发的)的配置文件.</p><p>Tips：AS在导入代码时比较慢，建议先修改android.iml，将自己用不到的代码exclude出去.可以仿照过滤.repo文件夹的语法,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/.repo&quot; /&gt;</div><div class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/abi&quot; /&gt;</div><div class="line">&lt;excludeFolder url=&quot;file://$MODULE_DIR$/art&quot; /&gt;</div><div class="line">...</div></pre></td></tr></table></figure><p>还可以通过as 的module settings - dependents 删除掉所有不需要的module-library项</p><p>这样在导入时就会跳过abi和art文件夹.过滤的越多，AS的处理速度就会越快.最后在AS中打开源码根目录下新生成的android.ipr</p><h4 id="解决源码中跳转错误问题"><a href="#解决源码中跳转错误问题" class="headerlink" title="解决源码中跳转错误问题"></a>解决源码中跳转错误问题</h4><p>要为当前工程设置正确的SDK和JDK，需要Android API 19 Platform，jdk 则无所谓，因为libcore 目录下包括了jdk 的源码。添加一个jdk 接着把classpath 所有项remove 掉，接着Android API 19 Platform 选择空的jdk.如下图<br><img src="http://img.blog.csdn.net/20180207145631611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ1NETm5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="步骤1"></p><p>点击Project<br><img src="http://img.blog.csdn.net/20180207145747921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ1NETm5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="步骤2"></p><p>点击Modules, 选择相应的代码模块，比如frameworks、packages 等源码目录，且把它们移动到最前优先从这两个文件夹下查找，而不是在Android.jar中查找<br><img src="http://img.blog.csdn.net/20180207145838877?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ1NETm5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>NOTE: Empty Library 不要紧的。</p><h4 id="DEBUG源码"><a href="#DEBUG源码" class="headerlink" title="DEBUG源码"></a>DEBUG源码</h4><p>在’Modules’中添加’Android Framework’来让AS将它作为一个Android工程，从而方便我们调试代码.<br><img src="http://img.blog.csdn.net/20180207150331651?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ1NETm5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>在代码中加断点，然后选择’Run’-&gt;’Attach debugger to Android process’或者直接点击ToolBar 上的Attach debugger图标。在弹出的选择进程(Choose Process)对话框中，勾选显示所有进程，选择要DEBUG的代码所在的进程，点击OK即可.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了学习Android 源码，在Mac 下编译Android源码，Android Studio 下调试。&lt;/p&gt;
    
    </summary>
    
      <category term="Android源代码学习" scheme="http://lazy.github.io/categories/Android%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深入理解Android" scheme="http://lazy.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 快速入门</title>
    <link href="http://lazy.github.io/2017/06/13/kotlin/Kotlin-quick-start/"/>
    <id>http://lazy.github.io/2017/06/13/kotlin/Kotlin-quick-start/</id>
    <published>2017-06-13T13:04:45.000Z</published>
    <updated>2018-01-15T15:08:38.284Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦多，快来 Kotlin ，快速学习Kotlin！</p><a id="more"></a> <h3 id="什么是Kotlin？"><a href="#什么是Kotlin？" class="headerlink" title="什么是Kotlin？"></a>什么是Kotlin？</h3><p>Kotlin 是种静态类型编程语言 用于现代多平台应用 100％可与Java™和Android™互操作,它是[JetBrains]开发的基于JVM的语言<br>开发IDE : <a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">Intellij</a> / <a href="https://developer.android.com/studio/preview/index.html" target="_blank" rel="external">AndroidStudio3.0 preview</a> </p><p>参考: <a href="https://kotlinlang.org/" target="_blank" rel="external">Kotlin 官网 </a> / <a href="https://www.kotlincn.net/" target="_blank" rel="external">Kotlin 语言中文站</a></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Github <a href="https://github.com/iflove/KotlinDemo" target="_blank" rel="external">KotlinDemo</a></p><h2 id="源文件与包"><a href="#源文件与包" class="headerlink" title="源文件与包"></a>源文件与包</h2><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Kotlin 源文件以 <strong>kt</strong> 结尾. 源文件所有内容（无论是类还是函数）都包含在声明的包内.<br>NOTE: 源文件通常以包声明开头, 没有指明包，则该文件的内容属于无名字的默认包（属于<strong>root package</strong>）。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> demo</div></pre></td></tr></table></figure></p><p>NOTE： 若声明的包路径与文件路径不一致，亦可以正常编译. 不过会有如Java 一样的警告 Package directive doesn’t match file location</p><h3 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h3><p>Kotlin 如同Java 一样 默认源文件会导入以下包:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">kotlin.*</div><div class="line">kotlin.<span class="keyword">annotation</span>.*</div><div class="line">kotlin.collections.*</div><div class="line">kotlin.comparisons.* （自 <span class="number">1.1</span> 起）</div><div class="line">kotlin.io.*</div><div class="line">kotlin.ranges.*</div><div class="line">kotlin.sequences.*</div><div class="line">kotlin.text.*</div><div class="line"><span class="comment">//根据目标平台还会导入额外的包：</span></div><div class="line">JVM:</div><div class="line">java.lang.*</div><div class="line">kotlin.jvm.*</div><div class="line">JS:</div><div class="line">kotlin.js.*</div></pre></td></tr></table></figure></p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><a href="https://www.kotlincn.net/docs/reference/grammar.html#import" target="_blank" rel="external">导入语法</a><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (used <span class="keyword">by</span> preamble)</div><div class="line">  : <span class="string">"import"</span> SimpleName&#123;<span class="string">"."</span>&#125; (<span class="string">"."</span> <span class="string">"*"</span> | <span class="string">"as"</span> SimpleName)? SEMI?</div><div class="line">  ;`</div></pre></td></tr></table></figure></p><p>Java vs Kotlin<br>1.如果出现名字冲突，Kotlin 可以使用 as 关键字在本地重命名冲突项来消歧义<br>2.Kotlin 的关键字 import 不仅仅限于导入类，还可以导入顶层函数及属性，在对象声明中声明的函数和属性，枚举常量等.</p><p>NOTE： 与 Java 不同，Kotlin 没有单独的 <code>import static</code> 语法； 所有这些声明都用 import 关键字导入。</p><h3 id="顶层声明"><a href="#顶层声明" class="headerlink" title="顶层声明"></a>顶层声明</h3><p>1.同 <strong>package</strong> 下的Kotlin 源文件,在顶层所声明的常量,变量以及函数等不允许重复定义,否则报<strong>Conflicting</strong> 错误。</p><p>2.若声明用 <strong>private</strong> 可见性修饰符修饰时,属于当前文件私有。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h3><p>Kotlin 一切都是对象。Kotlin提供以下代表数字、字符的内置类型（这很接近Java）</p><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Bit width</th><th style="text-align:left">包装器类型</th></tr></thead><tbody><tr><td style="text-align:left">Double</td><td style="text-align:left">64</td><td style="text-align:left">Double</td></tr><tr><td style="text-align:left">Float</td><td style="text-align:left">32</td><td style="text-align:left">Float</td></tr><tr><td style="text-align:left">Long</td><td style="text-align:left">64</td><td style="text-align:left">Long</td></tr><tr><td style="text-align:left">Int</td><td style="text-align:left">32</td><td style="text-align:left">Integer</td></tr><tr><td style="text-align:left">Short</td><td style="text-align:left">16</td><td style="text-align:left">Short</td></tr><tr><td style="text-align:left">Byte</td><td style="text-align:left">8</td><td style="text-align:left">Byte</td></tr><tr><td style="text-align:left">Char</td><td style="text-align:left">16 (Unicode character)</td><td style="text-align:left">Character</td></tr></tbody></table><p>NOTE:仅 <strong>Char</strong>  不是Kotlin的数字。如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> c:<span class="built_in">Char</span>=<span class="string">'c'</span></div><div class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = c.toInt()</div><div class="line">println(c) <span class="comment">// 'c'</span></div><div class="line">println(i) <span class="comment">// 99</span></div></pre></td></tr></table></figure><h4 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h4><p>Kotlin 唯独不支持八进制</p><ul><li>十进制: <code>123</code></li><li>二进制: <code>0b00001011</code></li><li>十六进制: <code>0x0F</code></li></ul><p>Kotlin 数值表示方法</p><ul><li>默认 Double：<code>123.5</code>、<code>123.5e10</code></li><li>Float 用 <code>f</code> 或者 <code>F</code> 标记: <code>123.5f</code></li><li>Long 用大写 <code>L</code> 标记: <code>123L</code></li></ul><p>NOTE：支持数字字面值中的下划线（自 kotlin1.1 起）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> oneMillion = <span class="number">1</span>_000_000</div></pre></td></tr></table></figure><h4 id="Kotlin-装箱机制"><a href="#Kotlin-装箱机制" class="headerlink" title="Kotlin 装箱机制"></a>Kotlin 装箱机制</h4><p>Kotlin 内置类型在 Java 平台上是存储为 JVM 的原生类型，但一个<a href="#空安全">可空的引用</a>（如 <code>Int?</code>）或泛型情况下(如 <code>Array&lt;Int&gt;,List&lt;Int&gt; ...</code>) 会把数字和字符自动装箱成相应包装类, 请参考 <a href="#Numbers">Numbers</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> low = <span class="number">-127</span></div><div class="line"><span class="keyword">val</span> high = <span class="number">127</span></div><div class="line"><span class="keyword">val</span> noInIntegerCache = <span class="number">128</span></div><div class="line"><span class="keyword">var</span> boxedA: <span class="built_in">Int</span>? = low</div><div class="line"><span class="keyword">var</span> anotherBoxedA: <span class="built_in">Int</span>? = low</div><div class="line">println(boxedA == anotherBoxedA) <span class="comment">//true</span></div><div class="line">println(boxedA === anotherBoxedA) <span class="comment">//true</span></div><div class="line">boxedA = high</div><div class="line">anotherBoxedA = high</div><div class="line">println(boxedA == anotherBoxedA) <span class="comment">//true</span></div><div class="line">println(boxedA === anotherBoxedA) <span class="comment">//true</span></div><div class="line">boxedA = noInIntegerCache</div><div class="line">anotherBoxedA = noInIntegerCache</div><div class="line">println(boxedA == anotherBoxedA) <span class="comment">//true</span></div><div class="line">println(boxedA === anotherBoxedA) <span class="comment">//false</span></div></pre></td></tr></table></figure><p><code>==</code> 和 <code>===</code> 请参考 <a href="#类型相等性">类型相等性</a> 。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> anIntegerA: <span class="built_in">Int</span>? = <span class="number">123</span> <span class="comment">//对应 java.lang.Integer 一个装箱的 Int</span></div><div class="line"><span class="keyword">val</span> anIntegerB: <span class="built_in">Int</span>? = <span class="number">123</span> <span class="comment">//对应 java.lang.Integer</span></div><div class="line">println(anIntegerA === anIntegerB) <span class="comment">//true</span></div><div class="line">println(anIntegerA?.javaClass) <span class="comment">//int</span></div><div class="line">println((anIntegerA <span class="keyword">as</span> Number).javaClass) <span class="comment">//java.lang.Integer</span></div><div class="line"><span class="keyword">val</span> anIntegerArray: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> anIntegerList: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">println(anIntegerArray.toString())</div><div class="line">println(anIntegerList.toString())</div><div class="line">println((anIntegerList[<span class="number">0</span>] <span class="keyword">as</span> Number).javaClass) <span class="comment">//</span></div></pre></td></tr></table></figure><p>NOTE：一个<a href="#空安全">可空的引用</a>（如 <code>Int?</code>）能不能装换成 <code>Int</code> ,答案是肯定的。强制转换或者 <code>!!</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> anIntegerA: <span class="built_in">Int</span>? = <span class="number">123</span> </div><div class="line"><span class="keyword">val</span> anNewIntA: <span class="built_in">Int</span> = anIntegerA  <span class="comment">//编译错误</span></div><div class="line"><span class="keyword">val</span> anNewIntB: <span class="built_in">Int</span> = anIntegerA!!  <span class="comment">//或者 anIntegerA as Int</span></div><div class="line"><span class="keyword">val</span> anNewIntC: <span class="built_in">Int</span> = anIntegerA <span class="comment">//Start cast to kotlin.Int</span></div></pre></td></tr></table></figure><h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>每个数字类型支持如下的转换:</p><ul><li><code>toByte(): Byte</code></li><li><code>toShort(): Short</code></li><li><code>toInt(): Int</code></li><li><code>toLong(): Long</code></li><li><code>toFloat(): Float</code></li><li><code>toDouble(): Double</code></li><li><code>toChar(): Char</code></li></ul><p>如下示例 Java 中,包装类不能隐式转换, Kotlin 也是如此, 不同类型之间是<strong>不能</strong>相互隐式转换的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Byte a  = <span class="number">1</span>;</div><div class="line">Integer b = a;<span class="comment">//error</span></div></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></div><div class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// 错误</span></div></pre></td></tr></table></figure><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>Kotlin支持数字运算的标准集，运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。 参见<a href="#操作符重载">操作符重载</a>。</p><p>对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = (<span class="number">1</span> shl <span class="number">2</span>) and <span class="number">0x000FF000</span></div></pre></td></tr></table></figure><p>这是完整的位运算列表（只用于 <code>Int</code> 和 <code>Long</code>）：</p><ul><li>shl(bits) – 有符号左移 (Java 的 &lt;&lt;)</li><li>shr(bits) – 有符号右移 (Java 的 &gt;&gt;)</li><li>ushr(bits) – 无符号右移 (Java 的 &gt;&gt;&gt;)</li><li>and(bits) – 位与</li><li>or(bits) – 位或</li><li>xor(bits) – 位异或</li><li>inv() – 位非</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串用 <code>String</code> 类型表示。字符串是不可变的。 字符串的元素——字符可以使用索引运算符访问: <code>s[i]</code>。 可以用 <em>for</em> 循环迭代字符串:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"Hello, world!\n"</span> <span class="comment">//字符串字面值</span></div><div class="line"><span class="comment">//字符串</span></div><div class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> s) &#123;</div><div class="line">    print(c)</div><div class="line">&#125;</div><div class="line"><span class="comment">//原生字符串 使用三个引号（"""）分界符括起来</span></div><div class="line"><span class="keyword">val</span> text = <span class="string">"""</span></div><div class="line">for (c in s) &#123;</div><div class="line">    print(c)</div><div class="line">&#125;</div><div class="line">"""</div><div class="line">println(text)</div><div class="line"><span class="comment">//字符串模板</span></div><div class="line"><span class="keyword">val</span> str = <span class="string">"<span class="subst">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span></div><div class="line">println(str)</div></pre></td></tr></table></figure><p>NOTE: 模板表达式以美元符（<code>$</code>）开头,若要对象属性时要花括号括起来，若要表示字面值 <code>$</code> 字符z则:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> price = <span class="string">"<span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>9.99"</span></div><div class="line">println(price)</div></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组在 Kotlin 中使用 <code>Array</code> 类来表示，它定义了 <code>get</code> 和 <code>set</code> 函数（按照运算符重载约定这会转变为 <code>[]</code>）和 <code>size</code> 属性，以及一些其他有用的成员函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="type">T</span>&gt; <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</div><div class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></div><div class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T</div><div class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span></div><div class="line"></div><div class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt;</div><div class="line">    <span class="comment">// ……</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Library.kt</code> 中 <code>arrayOf()</code> <code>arrayOfNulls</code> 函数以及<code>Array</code>构造函数能创建数数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> args: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> arrayOfNulls = arrayOfNulls&lt;<span class="built_in">Int</span>&gt;(<span class="number">10</span>) <span class="comment">//空数组</span></div><div class="line"><span class="keyword">val</span> initArray = Array(<span class="number">5</span>, &#123; i -&gt; (i * i).toString() &#125;) <span class="comment">//构造函数init</span></div><div class="line">println(arrayOfNulls.size)</div></pre></td></tr></table></figure><p>NOTE: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 <code>Array&lt;String&gt;</code>赋值给 <code>Array&lt;Any&gt;</code>，以防止可能的运行时失败（但是你可以使用 <code>Array&lt;out Any&gt;</code>, 参见<a href="#类型投影">类型投影</a>）。</p><p>之前所说的在泛型情况下Kotlin 会把数字和字符自动装箱成相应包装类, <code>Arrays.kt</code> 中有以下</p><p><code>ByteArray</code><br><code>CharArray</code><br><code>ShortArray</code><br><code>IntArray</code><br><code>LongArray</code><br><code>FloatArray</code><br><code>DoubleArray</code><br><code>BooleanArray</code></p><p>无装箱开销的专门的类来表示原生类型数组, 和 <code>Array</code> 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</div></pre></td></tr></table></figure><p>数组迭代通过 <code>iterator()</code> 函数返回 <code>Iterator&lt;T&gt;</code> 对象进行迭代：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> iterator = args.iterator()</div><div class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">    print(<span class="string">""</span> + iterator.next())</div><div class="line">&#125;</div><div class="line">println()</div><div class="line"><span class="comment">//forEach</span></div><div class="line">args.iterator().forEach &#123; print(it) &#125;</div><div class="line">println()</div><div class="line"><span class="comment">//for-</span></div><div class="line"><span class="keyword">for</span> (it <span class="keyword">in</span> initArray<span class="comment">/*.iterator()*/</span>) &#123;</div><div class="line">    print(it)</div><div class="line">&#125;</div><div class="line">println()</div><div class="line"><span class="comment">//下标索引</span></div><div class="line">args.forEachIndexed &#123; index, i -&gt; println(<span class="string">"<span class="subst">$index</span> = <span class="subst">$i</span>"</span>) &#125;</div></pre></td></tr></table></figure><p>NOTE: <code>forEach</code> <code>forEachIndexed</code>  这些是<strong>Array</strong> 的扩展函数, 背后实现也是 <a href="#For 循环">for 循环 </a></p><h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><p>区间表达式由具有操作符形式 <code>..</code> 的 <code>rangeTo</code> 和 <code>downTo</code> 函数辅以 <code>in</code> 和 <code>!in</code> 形成。 区间是为任何可比较类型（<code>Comparable&lt;in T&gt;</code>）定义的，但对于整型原生类型（Int ,Long,Char），<code>Ranges.kt</code> 中实现了常用的整型区间（<code>IntRange</code>、 <code>LongRange</code>、 <code>CharRange</code>）,而在 <code>Primitives.kt</code>中的 <code>Int ,Long,Char</code> 类实现了<code>rangeTo</code> 函数。以下是使用区间的一些示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">println((<span class="number">1.</span>rangeTo(<span class="number">3</span>)).contains(<span class="number">1</span>)) <span class="comment">//使用区间rangeTo函数</span></div><div class="line">println(<span class="number">1</span> <span class="keyword">in</span> (<span class="number">1.</span><span class="number">.3</span>)) <span class="comment">//使用区间操作符</span></div></pre></td></tr></table></figure><p> <code>..</code>  创建一个区间, 实际是调用  <code>rangeTo</code> 函数返回原生类型 <code>*Range</code> 对象, <code>in</code> 则调用 <code>contains</code>函数。<code>in *Range</code>  还可以用在迭代(<strong>for</strong>-循环)中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>) print(index)</div></pre></td></tr></table></figure><p>NOTE：<code>rangeTo</code>  创建的区间, 范围值是小到大, <code>downTo</code> 反之。他们默认 step 分别为1，-1</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//    val intRange = 1..4 //step 1 default</span></div><div class="line">    <span class="keyword">val</span> intRange = <span class="number">1.</span><span class="number">.4</span> step <span class="number">2</span> <span class="comment">//step 2</span></div><div class="line">    <span class="keyword">val</span> is2 = <span class="number">2</span> <span class="keyword">in</span> intRange</div><div class="line">    <span class="keyword">val</span> is4 = <span class="number">4</span> <span class="keyword">in</span> intRange</div><div class="line">    println(<span class="string">"first = <span class="subst">$&#123;intRange.first&#125;</span>,last = <span class="subst">$&#123;intRange.last&#125;</span>,step = <span class="subst">$&#123;intRange.step&#125;</span>"</span>)</div><div class="line">    println(is2)</div><div class="line">    println(is4)</div><div class="line">    println(is2 or is4)</div><div class="line"></div><div class="line"><span class="comment">//    for (index in 1..4) print(index)</span></div><div class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> intRange) print(index)</div><div class="line">    println()</div><div class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> intRange.reversed()) print(index)</div><div class="line">println()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">10.</span><span class="number">.1</span>) print(index) <span class="comment">//Nothing</span></div><div class="line">    println()</div><div class="line">    <span class="keyword">val</span> intProgression = <span class="number">10</span> downTo <span class="number">1</span> <span class="comment">/*step 2*/</span> <span class="comment">//step默认为1  倒序迭代</span></div><div class="line">    println(<span class="string">"first = <span class="subst">$&#123;intProgression.first&#125;</span>,last = <span class="subst">$&#123;intProgression.last&#125;</span>,step = <span class="subst">$&#123;intProgression.step&#125;</span>"</span>)</div><div class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> intProgression) print(index)</div><div class="line">    println()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>) print(index) <span class="comment">// 输出“1234”</span></div><div class="line"></div><div class="line">    <span class="keyword">val</span> isIn = <span class="number">3</span> <span class="keyword">in</span> <span class="number">1.</span>rangeTo(<span class="number">100</span>)</div><div class="line">    println(isIn)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="string">'a'</span>..<span class="string">'z'</span>) print(i)</div></pre></td></tr></table></figure><h4 id="背后实现原理"><a href="#背后实现原理" class="headerlink" title="背后实现原理"></a>背后实现原理</h4><p>区间实现了该库中的一个公共接口：<code>ClosedRange&lt;T&gt;</code>。</p><p><code>ClosedRange&lt;T&gt;</code> 在数学意义上表示一个闭区间，它是为可比较类型定义的。 它有两个端点：<code>start</code> 和 <code>endInclusive</code> 他们都包含在区间内。 其主要操作是 <code>contains</code>，通常以 <em>in</em>/<em>!in</em> 操作符形式使用。</p><p>整型数列（<code>IntProgression</code>、 <code>LongProgression</code>、 <code>CharProgression</code>）表示等差数列。 数列由 <code>first</code> 元素、<code>last</code> 元素和非零的 <code>step</code> 定义。 第一个元素是 <code>first</code>，后续元素是前一个元素加上 <code>step</code>。 <code>last</code> 元素总会被迭代命中，除非该数列是空的。</p><p>数列是 <code>Iterable&lt;N&gt;</code> 的子类型，其中 <code>N</code> 分别为 <code>Int</code>、 <code>Long</code> 或者 <code>Char</code>，所以它可用于 <em>for</em>-循环以及像 <code>map</code>、<code>filter</code> 等函数中。 对 <code>Progression</code> 迭代相当于 Java/JavaScript 的基于索引的 <em>for</em>-循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (int i = first; i != last; i += step) &#123;</div><div class="line">  // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于整型类型，<code>..</code> 操作符创建一个同时实现 <code>ClosedRange&lt;T&gt;</code> 和 <code>*Progression</code> 的对象。 例如，<code>IntRange</code> 实现了 <code>ClosedRange&lt;Int&gt;</code> 并扩展自 <code>IntProgression</code>，因此为 <code>IntProgression</code> 定义的所有操作也可用于 <code>IntRange</code>。 <code>downTo()</code> 和 <code>step()</code> 函数的结果总是一个 <code>*Progression</code>。</p><p>数列由在其伴生对象中定义的 <code>fromClosedRange</code> 函数构造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IntProgression.fromClosedRange(start, end, step)</div></pre></td></tr></table></figure><p>数列的 <code>last</code> 元素这样计算：对于正的 <code>step</code> 找到不大于 <code>end</code> 值的最大值、或者对于负的 <code>step</code> 找到不小于 <code>end</code> 值的最小值，使得 <code>(last - first) % increment == 0</code>。</p><h4 id="一些实用函数"><a href="#一些实用函数" class="headerlink" title="一些实用函数"></a>一些实用函数</h4><ul><li>rangeTo()</li><li>downTo()</li><li>reversed()</li><li>step()</li></ul><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>分别使用 <strong>var</strong>  ,<strong>val</strong>  声明可变和不可变的变量.例子如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"Example"</span> <span class="comment">// A Immutable String</span></div><div class="line"><span class="keyword">var</span> v = <span class="string">"Example"</span> <span class="comment">// A Mutable String</span></div></pre></td></tr></table></figure><p>声明可变变量语法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div></pre></td></tr></table></figure><p>声明不可变变量（仅赋值一次只读变量）语法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] = &lt;property_initializer&gt;</div></pre></td></tr></table></figure><p>默认 Kotlin 变量类型是能通过赋值时智能推断该变量的类型,且该<code>var</code>变量只能该类型的的值。显式确定变量类型,必须要接收该类型的初始化。通过一个简单例子说明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> aImmutableIntVariable = <span class="number">0x001</span> <span class="comment">//aImmutableIntVariable 类型为 Int</span></div><div class="line"><span class="keyword">var</span> aMutableIntVariable: <span class="built_in">Int</span> = <span class="string">"0x002"</span> <span class="comment">//语法error</span></div><div class="line"><span class="keyword">var</span> bMutableIntVariable: <span class="built_in">Int</span> = <span class="number">0x002</span></div><div class="line"><span class="keyword">var</span> cMutableVariable: Any <span class="comment">//显式确定变量类型,必须要接收该类型的初始化。</span></div><div class="line"></div><div class="line">aImmutableIntVariable = <span class="number">1</span> <span class="comment">//不能重新分配 Val cannot be reassigned</span></div><div class="line">bMutableIntVariable = <span class="string">""</span><span class="comment">//一旦类型确定,只能接受该类型的值</span></div></pre></td></tr></table></figure><p>NOTE: <code>var</code> 变量直接赋值为 <code>null</code> ,该变量则不符合预期的类型 简单来说（Nothing）,再次赋值时报错。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aNullable = <span class="literal">null</span></div><div class="line">aNullable = <span class="number">1</span>;<span class="comment">//Nothing</span></div></pre></td></tr></table></figure><p>更详细的类型介绍：<a href="#类型安全和智能转换">类型安全和智能转换</a></p><h3 id="常量-（编译期）"><a href="#常量-（编译期）" class="headerlink" title="常量 （编译期）"></a>常量 （编译期）</h3><p>已知值的属性可以使用  const 修饰符标记为 编译期常量.必须满足以下需求</p><ol><li>位于顶层或者是 object 的一个成员</li><li>String 或原生类型 值初始化</li><li>没有自定义 getter</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const <span class="keyword">val</span> CONST_VAL = <span class="number">1</span></div><div class="line"><span class="comment">//const val CONST_VAL_GET get() = 1 //Error: Const 'val' should not have a getter</span></div><div class="line"><span class="comment">//const val CONST_VAL_TEST :Any = 1  //error</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testConstInFunction</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="comment">//    const val CONST_VAL = 1 //error</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">object</span> Kotlin &#123;</div><div class="line">    const <span class="keyword">val</span> CONST_VAL: String = <span class="string">"object 常量"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="幕后字段"><a href="#幕后字段" class="headerlink" title="幕后字段"></a>幕后字段</h3><p>Kotlin 中类不能有字段。然而，当使用自定义访问器时，有时有一个幕后字段（backing field）有时是必要的。为此 Kotlin 提供一个自动幕后字段，它可通过使用 <code>field</code> 标识符访问。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span> <span class="comment">// 此初始器值直接写入到幕后字段</span></div><div class="line"><span class="keyword">set</span>(value) &#123;</div><div class="line">  <span class="keyword">if</span> (value &gt;= <span class="number">0</span>)</div><div class="line">  field = value</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>field</code> 标识符只能用在属性的访问器内。</p><p>如果属性至少一个访问器使用默认实现，或者自定义访问器通过 <code>field</code> 引用幕后字段，将会为该属性生成一个幕后字段。</p><p>例如，下面的情况下， 就没有幕后字段：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></div><div class="line"><span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></div></pre></td></tr></table></figure><p>如果你的需求不符合这套“隐式的幕后字段”方案，那么总可以使用 <strong>幕后属性（backing property）</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> _table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;</div><div class="line">    <span class="keyword">get</span>() &#123;</div><div class="line">        <span class="keyword">if</span> (_table == <span class="literal">null</span>) &#123;</div><div class="line">            _table = HashMap() <span class="comment">// 类型参数已推断出</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError(<span class="string">"Set to null by another thread"</span>)</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>从各方面看，这正是与 Java 相同的方式。因为通过默认 getter 和 setter 访问私有属性会被优化，所以不会引入函数调用开销。</p><h3 id="控制流：if、when、for、while"><a href="#控制流：if、when、for、while" class="headerlink" title="控制流：if、when、for、while"></a>控制流：if、when、for、while</h3><h4 id="if-语句、if-else-表达式"><a href="#if-语句、if-else-表达式" class="headerlink" title="if 语句、if - else 表达式"></a>if 语句、if - else 表达式</h4><p>在 Kotlin 中,没有Java中三元运算符（条件 ? 然后 : 否则）, 因为<strong>if - else</strong> 是一个表达式，即它会返回一个值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> num1 = <span class="number">1</span></div><div class="line"><span class="keyword">val</span> num2 = <span class="number">2</span></div><div class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (num1 &gt; num2) num1 <span class="keyword">else</span> num2</div><div class="line">println(max)</div><div class="line">println(<span class="keyword">if</span> (num1 &lt; num2) <span class="string">"if - else 表达式"</span> <span class="keyword">else</span> num2)</div></pre></td></tr></table></figure><p>if的分支可以是代码块，最后的表达式作为该块的值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">println(</div><div class="line">        <span class="keyword">if</span> (num1 &lt; num2) &#123;</div><div class="line">            println(<span class="string">"num1 &lt; num2"</span>)</div><div class="line">            <span class="string">"if - else 表达式"</span></div><div class="line">        &#125; <span class="keyword">else</span> num2</div><div class="line">)</div></pre></td></tr></table></figure><h4 id="When-表达式"><a href="#When-表达式" class="headerlink" title="When 表达式"></a>When 表达式</h4><p>在 Kotlin 中,<strong><code>when</code></strong> 取代了Java中 <code>switch</code> 。声明语法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">when</span>[(表达式)]&#123;</div><div class="line">  [条件分支<span class="number">1</span>,条件分支<span class="number">2</span>(可多个 逗号分隔)] -&gt; controlStructureBody [SEMI]</div><div class="line">  [<span class="keyword">else</span> 分支] -&gt; controlStructureBody [SEMI]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>SEMI 代表 <code>；或者 换行</code> , 在controlStructureBody 是代码块且有变量声明时使用, 示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">when</span> &#123;</div><div class="line">&#125; <span class="comment">//最简单的形式</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> randomNum = Random().nextInt(<span class="number">5</span>)</div><div class="line"><span class="keyword">when</span> (randomNum) &#123;</div><div class="line">  <span class="number">0</span>, <span class="number">1</span> -&gt; println(<span class="string">"randomNum == 0 or randomNum == 1"</span>) <span class="comment">//多个分支条件放在一起，用逗号分隔</span></div><div class="line">  <span class="number">2</span> -&gt; println(<span class="string">"randomNum == 2"</span>)</div><div class="line">  <span class="keyword">else</span> -&gt; println(<span class="string">"otherwise"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支</span></div><div class="line"><span class="keyword">when</span> &#123;</div><div class="line">  randomNum == <span class="number">0</span> -&gt; &#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">2</span>; println(<span class="string">"is 0"</span>) <span class="comment">//;</span></div><div class="line">    <span class="keyword">var</span> b = <span class="number">3</span></div><div class="line">    println(<span class="string">"is 0"</span>) <span class="comment">//换行</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//其他分支都不满足条件将会求值 else 分支</span></div><div class="line"><span class="keyword">when</span> &#123;</div><div class="line">  randomNum == <span class="number">0</span> -&gt; println(<span class="string">"randomNum is 0"</span>)</div><div class="line">  randomNum == <span class="number">1</span> -&gt; println(<span class="string">"randomNum is 1"</span>)</div><div class="line">  <span class="keyword">else</span> -&gt; println(<span class="string">"otherwise"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>NOTE: <code>when</code> 作为一个表达式使用，则必须有 <code>else</code> 分支， 除非所有的可能情况都已经覆盖了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> an = <span class="keyword">when</span> (<span class="number">1</span>) &#123;</div><div class="line">    <span class="number">1</span> -&gt; <span class="number">1</span></div><div class="line">    <span class="keyword">else</span> -&gt; <span class="string">"never arrive"</span></div><div class="line">&#125;</div><div class="line">println(an)</div><div class="line"><span class="keyword">when</span> (randomNum == <span class="number">3</span>) &#123;</div><div class="line">    <span class="literal">true</span> -&gt; println(<span class="string">"is 3"</span>)</div><div class="line">    <span class="literal">false</span> -&gt; println(randomNum)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h4><p><code>for</code> 循环可以对任何提供迭代器（iterator）的对象进行遍历。<a href="https://kotlinlang.org/docs/reference/grammar.html#for" target="_blank" rel="external">语法</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) print(item)</div><div class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> collection.indices) print(collection[index])</div></pre></td></tr></table></figure><p>示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">//for</span></div><div class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> array.indices) print(array[index]);println() <span class="comment">//索引遍历一个数组或者一个 list</span></div><div class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> array) print(item);println()</div><div class="line"><span class="comment">//库函数 forEachIndexed</span></div><div class="line">array.forEachIndexed &#123; index, item -&gt;  print(<span class="string">"[<span class="subst">$index</span>] = <span class="subst">$item</span> \t"</span>)&#125;</div><div class="line">println()</div><div class="line"><span class="comment">//库函数 withIndex</span></div><div class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</div><div class="line">    println(<span class="string">"the element at <span class="subst">$index</span> is <span class="subst">$value</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上所述，<strong>for</strong> 可以循环遍历任何提供了迭代器的对象。即：</p><ul><li>有一个成员函数或者扩展函数 <code>iterator()</code>，它的返回类型 <code>Iterator&lt;T&gt;</code></li><li>有一个成员函数或者扩展函数 <code>next()</code></li><li>有一个成员函数或者扩展函数 <code>hasNext()</code> 返回 <code>Boolean</code>。</li></ul><p>这三个函数都需要标记为 <code>operator</code>。</p><h4 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h4><p><code>while</code> 和 <code>do..while</code> 照常使用。小白应该也可以搞掂吧。。。</p><h4 id="循环中的Break和continue"><a href="#循环中的Break和continue" class="headerlink" title="循环中的Break和continue"></a>循环中的Break和continue</h4><p>在循环中 Kotlin 支持传统的 <code>break</code> 和 <code>continue</code> 操作符。</p><h3 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h3><p>Kotlin 有三种结构化跳转表达式：</p><ul><li>return。默认从最直接包围它的函数或者<a href="#匿名函数">匿名函数</a>返回。</li><li>break。终止最直接包围它的循环。</li><li>continue。继续下一次最直接包围它的循环。</li></ul><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 <code>@</code> 符号，例如：<code>abc@</code>、<code>fooBar@</code>都是有效的标签（参见<a href="https://www.kotlincn.net/docs/reference/grammar.html#labelReference" target="_blank" rel="external">语法</a>）。 要为一个表达式加标签，我们只要在其前加标签即可。</p><p>Break 和 Continue 的标签控制跳转, return 标签控制返回目标，示例:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">out@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (j == <span class="number">2</span>) <span class="keyword">break</span><span class="symbol">@out</span>;print(<span class="string">"[<span class="subst">$i</span> , <span class="subst">$j</span>] "</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">println()</div><div class="line"><span class="symbol">out@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (j == <span class="number">2</span>) <span class="keyword">continue</span><span class="symbol">@out</span>;print(<span class="string">"[<span class="subst">$i</span> , <span class="subst">$j</span>] "</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">println()</div><div class="line"><span class="keyword">var</span> nullInt: <span class="built_in">Int</span>? = <span class="number">1</span></div><div class="line">  nullInt = <span class="literal">null</span></div><div class="line"><span class="keyword">var</span> anLong = nullInt?.toLong() ?: <span class="keyword">return</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">performLabelReturn</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">    array.forEach &#123;</div><div class="line">        <span class="keyword">if</span> (it == <span class="number">2</span>) <span class="keyword">return</span>  <span class="comment">//</span></div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"performLabelReturn can't reach"</span>)</div><div class="line">&#125;</div><div class="line">performLabelReturn()</div><div class="line">println()</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">performLabelLambdaLimitReturn</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">    array.forEach &#123;</div><div class="line">        <span class="keyword">if</span> (it == <span class="number">2</span>) <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">//</span></div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"performLabelLambdaLimitReturn can reach"</span>)</div><div class="line">&#125;</div><div class="line">performLabelLambdaLimitReturn()</div><div class="line">println()</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">performLabelLimitReturn</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">    array.forEach <span class="symbol">limit@</span> &#123;</div><div class="line">        <span class="keyword">if</span> (it == <span class="number">2</span>) <span class="keyword">return</span><span class="symbol">@limit</span> <span class="comment">//</span></div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">    println(<span class="string">"performLabelLimitReturn can reach"</span>)</div><div class="line">&#125;</div><div class="line">performLabelLimitReturn()</div><div class="line">println()</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">performLabelAnonymousLambdaLimitReturn</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">    array.forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) <span class="keyword">return</span>  <span class="comment">// local return to the caller of the anonymous fun, i.e. the forEach loop</span></div><div class="line">        println(value)</div><div class="line">    &#125;)</div><div class="line">    println(<span class="string">"performLabelAnonymousLambdaLimitReturn can reach"</span>)</div><div class="line">&#125;</div><div class="line">performLabelAnonymousLambdaLimitReturn()</div><div class="line">println()</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">    <span class="keyword">return</span><span class="symbol">@a</span> <span class="number">12</span></div><div class="line">&#125;</div><div class="line">println(a())</div></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>声明类（class）语法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[访问修饰符 默认<span class="keyword">public</span>] [非访问修饰符 默认 <span class="keyword">final</span>] <span class="class"><span class="keyword">class</span> 类名 </span></div><div class="line">[访问修饰符 默认<span class="keyword">public</span>] [主构造函数] [参数] [: 父类 默认为 Any]  [类体]</div></pre></td></tr></table></figure></p><p>定义类，我们通过下面的例子来说明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyClass</span>  </span></div><div class="line">println(EmptyClass() <span class="keyword">is</span> Any)</div></pre></td></tr></table></figure><p>NOTE： [] 代表可以省略. Kotliin 中<strong>修饰符</strong> 与Java 略不同，Java语言提供了很多修饰符，主要分为以下两类：</p><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><p>更详细的 Java 修饰符 请参考<br><a href="http://www.runoob.com/java/java-modifier-types.html" target="_blank" rel="external">Java 修饰符 _ 菜鸟教程</a></p><p>Kotliin 中没显式声明<strong>修饰符</strong> ,默认可见性是 <code>public</code>。</p><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><p>类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 <em>可见性修饰符</em>。 （getter 总是与属性有着相同的可见性。） 在 Kotlin 中有这四个可见性修饰符：<code>private</code>、 <code>protected</code>、 <code>internal</code> 和 <code>public</code>。</p><table><thead><tr><th>修饰符</th><th>是否支持顶级声明</th><th>当前文件</th><th>同一模块</th></tr></thead><tbody><tr><td>private</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>protected</td><td>N</td><td>~~~~</td><td>~~~~</td></tr><tr><td>internal</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><p>NOTE:</p><ol><li><p><code>protected</code> 不支持顶级声明,因为文件没有继承关系。</p></li><li><blockquote><p><code>internal</code> 是编译在一起的一套 Kotlin 文件：</p><ul><li>一个 IntelliJ IDEA 模块；</li><li>一个 Maven 项目；</li><li>一个 Gradle 源集；</li><li>一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。</li></ul></blockquote></li><li><blockquote><p>对于类和接口内部声明的成员可见修饰符与Java 类似:</p><ul><li><code>private</code> 仅该类和接口内部可见；</li><li><code>protectd</code> 该类和接口内部可见且子类可见</li><li><code>internal</code> <em>该模块内</em> 可见</li><li><code>public</code> 都可见</li></ul></blockquote></li></ol><h4 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符"></a>非访问控制修饰符</h4><p>kotlin 定义类、对象、构造函数、方法、属性时默认加了 <code>final</code> 修饰符, 接口默认是  <code>open</code> 与之相反。能被继承、被覆盖。</p><p>NOTE：在 final 修饰 class 下 用 open 修饰该类的成员无效，在 final 缺省修饰符下 再用 final 修饰显得 <code>Redundant</code> 冗余，但在 <code>override</code> 时可使用<code>final</code> 关键字再度修饰</p><p>我们通过下面的例子来说明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> name = <span class="string">"哔哔"</span> <span class="comment">//private can't open</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="keyword">val</span> bloodType = <span class="string">"AB"</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> number = <span class="number">1000</span></div><div class="line">    <span class="keyword">open</span> <span class="keyword">val</span> age = <span class="number">28</span></div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</div><div class="line">        <span class="keyword">val</span> body = &#123;&#125;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">val</span> cipher = <span class="literal">null</span></div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</div><div class="line">            <span class="comment">//can't access private</span></div><div class="line"><span class="comment">//            println(name)</span></div><div class="line"><span class="comment">//            println(bloodType)</span></div><div class="line"><span class="comment">//            println(number)</span></div><div class="line"><span class="comment">//            println(age)</span></div><div class="line"></div><div class="line">            body</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</div><div class="line">        println(name) <span class="comment">//can't access private</span></div><div class="line">        println(bloodType)</div><div class="line">        println(number)</div><div class="line">        println(age)</div><div class="line"></div><div class="line">        Nested().body</div><div class="line"></div><div class="line"><span class="comment">//        Nested().cipher//Kotlin 中外部类不能访问内部类的 private 成员</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> : <span class="type">Father</span></span>() &#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">final</span> <span class="keyword">val</span> bloodType: String = <span class="string">"O"</span> <span class="comment">//protected // final Redundant</span></div><div class="line"><span class="comment">//    override public val bloodType: String = "O" // 能覆盖</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">10</span> <span class="comment">// public</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; <span class="comment">//Warning: 'open' has no effect in a final class</span></div><div class="line"><span class="comment">//        println(name) //can't access private</span></div><div class="line">        println(bloodType)</div><div class="line">        println(number)</div><div class="line">        println(age)</div><div class="line"></div><div class="line">        Nested().body</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BigSon</span> : <span class="type">Father</span></span>() &#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">final</span> <span class="keyword">val</span> bloodType: String = <span class="string">"AB"</span>  <span class="comment">//can use final</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>NOTE：局部变量、函数和类不能有可见性修饰符。Kotlin 中外部类不能访问内部类的 private 成员(与Java不同)。</p><h4 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h4><p>类可以包含</p><ul><li><a href="#构造函数">构造函数</a>和初始化块</li><li><a href="#函数">函数</a></li><li><a href="#属性">属性</a></li><li><a href="#嵌套类和内部类">嵌套类和内部类</a></li><li><a href="#对象声明l">对象声明</a></li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（和访问修饰符 [默认 public]）后。主构造函数有注解或可见性修饰符，这个 <strong>constructor</strong> 关键字是必需的，并且这些修饰符在它前面。非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。</p><p>NOTE：若要修改主构造函数的可见性,需要添加一个显式 <strong>constructor</strong> 关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class A private constructor() &#123; …… &#125;</div></pre></td></tr></table></figure><p>Kotlin 十分简便, 可以在<strong>主构造函数</strong>内声明属性（可变的（var）或只读的（val））以及初始化属性默认值（<strong>次构造函数</strong>是不允许的）, 且为该类成员属性, <strong>主构造函数</strong>内不能包含除了声明属性任何的代码。提供了 <strong>init</strong> 关键字作为前缀的<strong>初始化块（initializer blocks）</strong>。</p><h4 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h4><p>声明在类体内以 <code>constructor</code> 关键字的函数。若该类有主构造函数,次构造函数都需要用 <code>this</code> 关键字直接或间接委托给主构造函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> /*<span class="keyword">private</span>*/ <span class="keyword">constructor</span></span>(firstName: String) &#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> //<span class="title">empty</span> <span class="title">class</span> 下面接着是次构造函数 ，<span class="title">Error</span>: <span class="type">Expecting member declaration</span>, <span class="type">期待成员声明</span></span></div><div class="line"></div><div class="line">    <span class="keyword">val</span> money = <span class="number">1000</span>_000</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">        println(<span class="string">"init block: firstName= <span class="subst">$firstName</span>"</span>)</div><div class="line">        println(<span class="string">"init block: money= <span class="subst">$money</span>"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//次构造函数</span></div><div class="line">    <span class="keyword">constructor</span>(firstName: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(firstName) &#123;</div><div class="line">        println(<span class="string">"secondary constructor: firstName= <span class="subst">$firstName</span>"</span>)</div><div class="line">        println(<span class="string">"secondary constructor: age= <span class="subst">$age</span>"</span>)</div><div class="line">        println(<span class="string">"init block: money= <span class="subst">$money</span>"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span> (firstName: String, age: <span class="built_in">Int</span>, money: <span class="built_in">Int</span>) : <span class="keyword">this</span>(firstName, age) &#123;</div><div class="line">        println(<span class="string">"secondary constructor: firstName= <span class="subst">$firstName</span>"</span>)</div><div class="line">        println(<span class="string">"secondary constructor: age= <span class="subst">$age</span>"</span>)</div><div class="line">        println(<span class="string">"init block: money= <span class="subst">$money</span>"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>(<span class="keyword">val</span> customerName: String = <span class="string">""</span>)</div></pre></td></tr></table></figure><h4 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h4><p>Kotlin 并不需要 new 关键字创建实例, 像普通函数一样调用构造函数即可。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Java 的超类是 <code>Object</code> , 而 Kotlin 的是 Any。</p><p>若父类有主构造函数且带参数,子类必须用主构造函数将参数初始化，如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(firstName: String) : Person(firstName) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意:参数初始化时,子父类必须一致。</p><p>父类没有主构造函数, 那么每个次构造函数必须使用 super 关键字初始化其基类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name: String) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> : <span class="type">Human &#123;</span></span></div><div class="line">    <span class="keyword">constructor</span>(name: String) : <span class="keyword">super</span>(name)</div><div class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//允许通过主构造函数覆盖次构造函数</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>(name: String) : Human(name)</div></pre></td></tr></table></figure><h4 id="覆盖-override"><a href="#覆盖-override" class="headerlink" title="覆盖(override)"></a>覆盖(<strong>override</strong>)</h4><p> <code>final</code> , <code>open</code> 是否可覆盖修饰符 和 <code>override</code>  标注覆盖类、对象、接口、构造函数、方法、属性。</p><h4 id="覆盖规则"><a href="#覆盖规则" class="headerlink" title="覆盖规则"></a>覆盖规则</h4><p>在 Kotlin 中，实现继承由下述规则规定:如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现(也许用继承来的其中之一)来消除歧义。 为了表示采用 从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super ，如 super<base> :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"Thread#run"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"Thread#start"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"Thread#run"</span>)</div><div class="line">    &#125; <span class="comment">// 接口成员默认就是“open”的</span></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span></span>() : Runnable, Thread() &#123;</div><div class="line">    <span class="comment">//编译器要求覆盖 run():</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>&lt;Thread&gt;.run() <span class="comment">// 调用 Thread.run()</span></div><div class="line">        <span class="keyword">super</span>&lt;Runnable&gt;.run() <span class="comment">// 调用 Runnable.run()</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>类和其中的某些成员可以声明为 abstract 。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span>&#123; <span class="comment">//open 多余的,因为抽象类终究是父类,所以更不能用final 修饰</span></div><div class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> <span class="comment">//子类必须 override</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClassImpl</span> : <span class="type">AbstractClass</span></span>() &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;<span class="comment">//override 开放成员</span></div><div class="line">        <span class="keyword">super</span>.doSomething()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>用关键字 <strong>interface</strong> 来定义接口。Kotlin 的接口函数可以有实现, 属性必须是抽象的（默认抽象）, 或者提供 <code>get</code> 访问器实现, 且不能有幕后字段(backing field)。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> kotlinLanguage = KotlinLanguage()</div><div class="line">    println(kotlinLanguage.language)</div><div class="line">    println(kotlinLanguage.that)</div><div class="line">    println(kotlinLanguage.that === kotlinLanguage)</div><div class="line">    kotlinLanguage.onReady()</div><div class="line">    kotlinLanguage.onUpgrade()</div><div class="line"></div><div class="line">    MultipurposePrinter().print()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">KotlinInterface</span> </span>&#123;</div><div class="line">    <span class="keyword">val</span> language <span class="keyword">get</span>() = <span class="string">"Kotlin"</span></div><div class="line">    <span class="keyword">val</span> that: KotlinInterface</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onUpgrade</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"call#onUpgrade"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onReady</span><span class="params">()</span></span> <span class="comment">//</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinLanguage</span> : <span class="type">KotlinInterface &#123;</span></span></div><div class="line">    <span class="keyword">override</span> <span class="keyword">val</span> that: KotlinInterface</div><div class="line">        <span class="keyword">get</span>() = <span class="keyword">this</span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReady</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"call#onReady"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ColorPrinter</span> : <span class="type">Printer &#123;</span></span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"ColorPrinter#print"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//    val printerType get() = "ColorPrinter"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BlackPrinter</span> : <span class="type">Printer &#123;</span></span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"BlackPrinter#print"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> printerType <span class="keyword">get</span>() = <span class="string">"BlackPrinter"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipurposePrinter</span> : <span class="type">ColorPrinter</span>, <span class="type">BlackPrinter &#123;</span></span></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"MultipurposePrinter#print"</span>)</div><div class="line">        <span class="keyword">super</span>&lt;BlackPrinter&gt;.print()</div><div class="line">        <span class="keyword">super</span>&lt;ColorPrinter&gt;.print()</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.printerType</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="嵌套类和内部类"><a href="#嵌套类和内部类" class="headerlink" title="嵌套类和内部类"></a>嵌套类和内部类</h3><p>类可以嵌套在其他类中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    println(KotlinNestedInnerClass.KotlinNestedClass().bra())</div><div class="line">    println(KotlinNestedInnerClass().KotlinInnerClass().bra())</div><div class="line">    println(KotlinNestedInnerClass().KotlinInnerClass().reference())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinNestedInnerClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bra: String = <span class="string">"C"</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KotlinNestedClass</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bra</span><span class="params">()</span></span> = KotlinNestedInnerClass().bra</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//内部类 标记为 inner 以便能够访问外部类的成员。内部类会带有一个对外部类的对象的引用</span></div><div class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">KotlinInnerClass</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bra</span><span class="params">()</span></span> = bra</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">reference</span><span class="params">()</span></span> = <span class="keyword">this</span><span class="symbol">@KotlinNestedInnerClass</span>  <span class="comment">//This 表达式</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//匿名内部类 @see 对象声明(object)</span></div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果对象是函数式 Java 接口（即具有单个抽象方法的 Java 接口）的实例， 你可以使用带接口类型前缀的lambda表达式创建它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> run  = Runnable &#123;  &#125;</div></pre></td></tr></table></figure><h3 id="对象-object"><a href="#对象-object" class="headerlink" title="对象(object)"></a>对象(object)</h3><p>在Java 中, 匿名内部类随处可见。然而 Kotlin 用 <code>object</code> 关键字提供了对象声明以及对象表达式特性, 创建单例、匿名对象, 伴生对象(类内部的对象声明) so easy。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> point = <span class="keyword">object</span> <span class="comment">/*: Any()*/</span> &#123; <span class="comment">//默认继承 Any</span></div><div class="line">    <span class="keyword">var</span> x: <span class="built_in">Int</span> = <span class="number">0</span> <span class="comment">//必须进行初始化</span></div><div class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"point[<span class="subst">$x</span>，<span class="subst">$y</span>]"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">point.x = <span class="number">100</span></div><div class="line">point.y = <span class="number">300</span></div><div class="line">println(point)</div><div class="line"><span class="keyword">val</span> singleton = Singleton</div><div class="line"><span class="keyword">val</span> singleton1 = Singleton</div><div class="line">println(singleton === singleton1)</div><div class="line"></div><div class="line"><span class="comment">//对象声明</span></div><div class="line"><span class="keyword">object</span> Singleton &#123; <span class="comment">//决不能声明局部作用域(函数中)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>NOTE: 如何区分对象声明和对象表达式, 顾名思义, 有名字的是对象声明（object Singleton）, 没名字的是对象表达式（anonymous object）。</p><p>关于 <code>object</code> 使用细节,下面通过一个简单例子为大家演示:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">privateObject</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123; <span class="comment">//返回: &lt;anonymous object : Any&gt;</span></div><div class="line">        <span class="keyword">val</span> name = <span class="string">"123"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">publicObject</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123; <span class="comment">// 返回Any 建议private</span></div><div class="line">        <span class="keyword">val</span> name = <span class="string">"ABC"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</div><div class="line">        println(privateObject().name)</div><div class="line">        <span class="comment">//println(publicObject().name) //错误：未能解析的引用“name”</span></div><div class="line">        <span class="keyword">var</span> visible = <span class="literal">true</span></div><div class="line">        call(<span class="keyword">object</span> : CallBack &#123;</div><div class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</div><div class="line">                visible <span class="comment">//对象表达式中的代码可以访问来自包含它的作用域的变量</span></div><div class="line">                println(<span class="string">"Anonymous#call@<span class="subst">$&#123;this.hashCode()&#125;</span>"</span>)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;)</div><div class="line">        call (<span class="keyword">object</span> : CallBack &#123;</div><div class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</div><div class="line">                visible <span class="comment">//对象表达式中的代码可以访问来自包含它的作用域的变量</span></div><div class="line">                println(<span class="string">"Anonymous#call@<span class="subst">$&#123;this.hashCode()&#125;</span>"</span>)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;)</div><div class="line">        call(OneCallBack)</div><div class="line">        call(OneCallBack)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">object</span> OneCallBack : CallBack &#123;</div><div class="line">        <span class="comment">//因为对象表达式不能绑定名字,这称为对象声明</span></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</div><div class="line">            println(<span class="string">"OneCallBack#call@<span class="subst">$&#123;this.hashCode()&#125;</span>"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(call: <span class="type">CallBack</span>)</span></span> &#123;</div><div class="line">        call.call()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span>: <span class="built_in">Unit</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">KotlinObject().run()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>私有函数时,返回<code>object</code>类型是匿名对象类型, 否则是 <code>Any</code>。与Java 不同内部类也可访问非 final 变量。对象声明实则是单例。</p><h4 id="伴生对象（companion-object）"><a href="#伴生对象（companion-object）" class="headerlink" title="伴生对象（companion object）"></a>伴生对象（companion object）</h4><p>与 Java 或 C# 不同，在 Kotlin 中类没有静态方法。在大多数情况下，它建议简单地使用包级函数。</p><p>类内部的对象声明可以用 <code>companion</code> 关键字标记：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">World</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//Companion 是companion object 默认名字可省略,仅且有一个伴生对象</span></div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Companion : Observer &#123;</div><div class="line">        <span class="meta">@JvmField</span> <span class="comment">//@JvmField 标注这样的属性使其成为与属性本身具有相同可见性的静态字段。</span></div><div class="line">        <span class="keyword">val</span> time = System.nanoTime()</div><div class="line"></div><div class="line">        const <span class="keyword">val</span> VERSION = <span class="string">"1.1.4.2"</span> <span class="comment">//kotlin 常量(const 标注的（在类中以及在顶层的）属性), 在 Java 中会成为静态字段：</span></div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(o: <span class="type">Observable</span>?, arg: <span class="type">Any</span>?)</span></span> &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//        @JvmStatic  //打开注释编译报错,存在相同的函数声明, 这充分地证明了伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</div><div class="line">            println(<span class="string">"sayHello@<span class="subst">$&#123;this.hashCode()&#125;</span> "</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"sayHello@<span class="subst">$&#123;this.hashCode()&#125;</span> "</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    World.sayHello()</div><div class="line">    World.Companion.sayHello()</div><div class="line">    World().sayHello()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Java 中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(World.Companion);</div><div class="line">        System.out.println(World.VERSION);</div><div class="line">        System.out.println(World.time);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>NOTE:伴生对象实际是对象的实例成员， JVM 平台，如果使用 <code>@JvmStatic</code> 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见<a href="https://www.kotlincn.net/docs/reference/java-to-kotlin-interop.html#静态字段" target="_blank" rel="external">Java 互操作性</a>一节 。</p><p>对象表达式和对象声明之间有一个重要的语义差别：</p><ul><li>对象表达式是在使用他们的地方<strong>立即</strong>执行（及初始化）的</li><li>对象声明是在第一次被访问到时<strong>延迟</strong>初始化的</li><li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配</li></ul><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>我们经常创建一些只保存数据的类。在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 <strong>数据类</strong> 并标记为 <code>data</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> user1 = KotlinDataClass.User(<span class="string">"小明"</span>, <span class="number">19</span>)</div><div class="line">    <span class="keyword">val</span> user2 = KotlinDataClass.User(<span class="string">"小明"</span>, <span class="number">19</span>)</div><div class="line">    println(user1 == user2)</div><div class="line">    println(user1)</div><div class="line">    <span class="keyword">val</span> copyXiaoMing = user1.copy(age = <span class="number">20</span>)</div><div class="line">    println(copyXiaoMing)</div><div class="line">    println(user1.component1())</div><div class="line">    <span class="keyword">val</span> bb = KotlinDataClass.User(<span class="string">"bb"</span>)</div><div class="line">    println(bb)</div><div class="line"></div><div class="line">    <span class="comment">//数据类和解构声明</span></div><div class="line">    <span class="keyword">val</span> (name, age) = KotlinDataClass.User(<span class="string">"Lisa"</span>, <span class="number">18</span>)</div><div class="line">    println(<span class="string">"<span class="subst">$name</span>, <span class="subst">$age</span> years of age"</span>)</div><div class="line"></div><div class="line">    <span class="comment">//标准数据类</span></div><div class="line">    <span class="keyword">val</span> anPair: Pair&lt;<span class="built_in">Char</span>, <span class="built_in">Char</span>&gt; = Pair(<span class="string">'A'</span>, <span class="string">'B'</span>)</div><div class="line">    println(<span class="string">"first = <span class="subst">$&#123;anPair.first&#125;</span>, second = <span class="subst">$&#123;anPair.second&#125;</span>"</span>)</div><div class="line">    <span class="keyword">val</span> (a,b,c) = Triple(<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>)</div><div class="line">    println(<span class="string">"(<span class="subst">$a</span>, <span class="subst">$b</span>, <span class="subst">$c</span>)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinDataClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">    <span class="comment">//数据类本身是 final,必须有主构造器,至少一个参数</span></div><div class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>) : Person() &#123;</div><div class="line"></div><div class="line">        <span class="comment">//编译器会根据主构造函数的参数生成以下函数,根据需求 override</span></div><div class="line"></div><div class="line"><span class="comment">//    override fun equals(other: Any?): Boolean &#123;</span></div><div class="line"><span class="comment">//        return super.equals(other)</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    override fun hashCode(): Int &#123;</span></div><div class="line"><span class="comment">//        return super.hashCode()</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    override fun toString(): String &#123;</span></div><div class="line"><span class="comment">//        return super.toString()</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"></div><div class="line"><span class="comment">//    Error: Conflicting overloads:</span></div><div class="line"><span class="comment">//    fun component1()&#123;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译器自动从主构造函数中声明的所有属性导出以下成员：</p><ul><li><code>equals()</code>/<code>hashCode()</code> 对，</li><li><code>toString()</code> 格式是 <code>&quot;User(name=John, age=42)&quot;</code>，</li><li><a href="#函数"><code>componentN()</code> 函数</a> 按声明顺序对应于所有属性，</li><li><code>copy()</code> 函数, 复制一个对象仅改变某些属性。</li></ul><p>为了确保生成的代码的一致性和有意义的行为，数据类必须满足以下要求：</p><ul><li>主构造函数需要至少有一个参数；</li><li>主构造函数的所有参数需要标记为 <code>val</code> 或 <code>var</code>；</li><li>数据类不能是抽象、开放、密封或者内部的；</li><li>（在1.1之前）数据类只能实现接口。</li></ul><p>自 1.1 起，数据类可以扩展其他类（示例请参见<a href="#密封类">密封类</a>）。</p><p>在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。 （参见<a href="https://www.kotlincn.net/docs/reference/classes.html#构造函数" target="_blank" rel="external">构造函数</a>）。</p><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。在某种意义上，他们是<a href="#枚举类">枚举类</a>的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。</p><p>NOTE： <code>sealed</code> 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> kotlinSealedClass = ChildrenKotlinSealedClass()</div><div class="line">    println(eval(kotlinSealedClass))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinSealedClass</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenKotlinSealedClass</span> : <span class="type">KotlinSealedClass</span></span>()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlKotlinSealedClass</span> : <span class="type">KotlinSealedClass</span></span>()</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(k: <span class="type">KotlinSealedClass</span>)</span></span>: String = <span class="keyword">when</span> (k) &#123;</div><div class="line">    <span class="keyword">is</span> ChildrenKotlinSealedClass -&gt; <span class="string">"ChildrenKotlinSealedClass"</span></div><div class="line">    <span class="keyword">is</span> GirlKotlinSealedClass -&gt; <span class="string">"GirlKotlinSealedClass"</span></div><div class="line">    <span class="comment">//不再需要 else 分支 已经覆盖了所有的情况</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举类的最基本的用法是实现类型安全的枚举, 每个枚举常量都是一个对象, 需用逗号分开。示例如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> (it <span class="keyword">in</span> KotlinEnumClass.Direction.values()) &#123;</div><div class="line">        println(it)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//必须与声明枚举类型名称一致, 否则抛出 IllegalArgumentException 异常。</span></div><div class="line">    <span class="keyword">val</span> north = KotlinEnumClass.Direction.valueOf(<span class="string">"NORTH"</span>)</div><div class="line">    println(north === KotlinEnumClass.Direction.NORTH)</div><div class="line"></div><div class="line">    <span class="comment">//枚举常量都具有在枚举类声明中获取其名称和位置的属性</span></div><div class="line">    <span class="keyword">val</span> (name, ordinal) = KotlinEnumClass.Direction.EAST</div><div class="line">    println(<span class="string">"<span class="subst">$name</span> <span class="subst">$ordinal</span>"</span>)</div><div class="line"></div><div class="line"></div><div class="line">    KotlinEnumClass().printAllValues&lt;KotlinEnumClass.ProtocolState&gt;()</div><div class="line">    println()</div><div class="line">    KotlinEnumClass().printValue&lt;KotlinEnumClass.ProtocolState&gt;(<span class="string">"WAITING"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinEnumClass</span> </span>&#123;</div><div class="line">    <span class="comment">//类型安全的枚举</span></div><div class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</div><div class="line">        NORTH, SOUTH, WEST, EAST;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//枚举都是枚举类的实例,可以初始化</span></div><div class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">val</span> rgb: <span class="built_in">Int</span>) &#123;</div><div class="line">        RED(<span class="number">0xFF0000</span>),</div><div class="line">        GREEN(<span class="number">0x00FF00</span>),</div><div class="line">        BLUE(<span class="number">0x0000FF</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//枚举常量也可以声明自己的匿名类</span></div><div class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolState</span> </span>&#123;</div><div class="line">        WAITING &#123;</div><div class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = TALKING</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        TALKING &#123;</div><div class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span> = WAITING</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">signal</span><span class="params">()</span></span>: ProtocolState</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//列出定义的枚举常量</span></div><div class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Enum&lt;T&gt;</span>&gt; <span class="title">printAllValues</span><span class="params">()</span></span> &#123;</div><div class="line">        print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//通过名称获取枚举常量</span></div><div class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Enum&lt;T&gt;</span>&gt; <span class="title">printValue</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</div><div class="line">        print(enumValueOf&lt;T&gt;(name))</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>枚举常量还实现了 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html" target="_blank" rel="external">Comparable</a> 接口， 其中自然顺序是它们在枚举类中定义的顺序。</p><p>NOTE: <code>val (name, ordinal) = KotlinEnumClass.Direction.EAST</code>  之所以可以编译通过, 因为我对枚举类进行<a href="#解构声明">解构声明</a> </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//学而致用</span></div><div class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Enum&lt;E&gt;</span>&gt; Enum<span class="type">&lt;E&gt;</span>.<span class="title">component1</span><span class="params">()</span></span> = <span class="keyword">this</span>.name</div><div class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Enum&lt;E&gt;</span>&gt; Enum<span class="type">&lt;E&gt;</span>.<span class="title">component2</span><span class="params">()</span></span> = <span class="keyword">this</span>.ordinal</div></pre></td></tr></table></figure><h3 id="注解类"><a href="#注解类" class="headerlink" title="注解类"></a>注解类</h3><p>学习Java 的应该对注解不陌生,不了解可以先看看<a href="http://wiki.jikexueyuan.com/project/java-reflection/java-at.html" target="_blank" rel="external"> Java的注解</a>。</p><h4 id="注解声明"><a href="#注解声明" class="headerlink" title="注解声明"></a>注解声明</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[访问修饰符 默认<span class="keyword">public</span>] [非访问修饰符 默认只能为 <span class="keyword">final</span> 不能显式修饰] <span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> 类名 </span></div><div class="line">[访问修饰符 只能为<span class="keyword">public</span>] [主构造函数 <span class="keyword">constructor</span> 关键字可有可无] [<span class="keyword">val</span>参数]</div></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinFileName</span></span>(<span class="keyword">val</span> name:String)</div></pre></td></tr></table></figure><p>允许的参数类型有：</p><ul><li>对应于 Java 原生类型的类型（Int、 Long等）以及字符串</li><li>类 <code>KClass</code>、枚举</li><li>其他注解</li><li>上面已列类型的数组</li></ul><p>NOTE: 注解参数不能有可空类型，因为 JVM 不支持将 <code>null</code> 作为注解属性的值存储。如果注解用作另一个注解的参数，则其名称不以 @ 字符为前缀, 且新的注解类访问权限不能比其中一个注解的参数的访问权限要大</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">internal</span> <span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">FileScope</span> </span></div><div class="line"><span class="keyword">constructor</span>(<span class="meta">@ApplicationScope</span> <span class="keyword">val</span> file: KotlinFileName)</div></pre></td></tr></table></figure><p>注解的附加属性可以通过用元注解标注注解类来指定：</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html" target="_blank" rel="external"><code>@Target</code></a> 指定可以用该注解标注的元素的可能的类型（类、函数、属性、表达式等）；</li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-retention/index.html" target="_blank" rel="external"><code>@Retention</code></a> 指定该注解是否存储在编译后的 class 文件中，以及它在运行时能否通过反射可见 （默认都是 true）；</li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-repeatable/index.html" target="_blank" rel="external"><code>@Repeatable</code></a> 允许在单个元素上多次使用相同的该注解；</li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-must-be-documented/index.html" target="_blank" rel="external"><code>@MustBeDocumented</code></a> 指定该注解是公有 API 的一部分，并且应该包含在生成的 API 文档中显示的类或方法的签名中。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target(AnnotationTarget.CLASS,</span></div><div class="line">        AnnotationTarget.FILE,</div><div class="line">        AnnotationTarget.FUNCTION,</div><div class="line">        AnnotationTarget.VALUE_PARAMETER,</div><div class="line">        AnnotationTarget.EXPRESSION)</div><div class="line"><span class="meta">@Retention(AnnotationRetention.SOURCE)</span></div><div class="line"><span class="meta">@MustBeDocumented</span></div><div class="line"><span class="keyword">annotation</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationScope</span></span></div></pre></td></tr></table></figure><h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><p>注解也可以用于 lambda 表达式。它们会被应用于生成 lambda 表达式体的 <code>invoke()</code> 方法上。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymous</span></span></div><div class="line"><span class="keyword">val</span> run = <span class="meta">@KotlinAnnotation</span>.Anonymous &#123; println(<span class="string">"run"</span>) &#125;</div></pre></td></tr></table></figure><h4 id="Use-site-Targets-使用处-目标"><a href="#Use-site-Targets-使用处-目标" class="headerlink" title="Use-site Targets (使用处 目标)"></a>Use-site Targets (使用处 目标)</h4><p>当对属性或主构造函数参数进行标注时，从相应的 Kotlin 元素生成的 Java 元素会有多个，因此在生成的 Java 字节码中该注解有多个可能位置 。支持的使用处目标的完整列表为：</p><ul><li><code>file</code></li><li><code>property</code>（具有此目标的注解对 Java 不可见）</li><li><code>field</code></li><li><code>get</code>（属性 getter）</li><li><code>set</code>（属性 setter）</li><li><code>receiver</code>（扩展函数或属性的接收者参数）</li><li><code>param</code>（构造函数参数）</li><li><code>setparam</code>（属性 setter 参数）</li><li><code>delegate</code>（为委托属性存储其委托实例的字段）</li></ul><p>可以使用相同的语法来注释整个文件。要执行此操作，请将目标文件的注释放在文件的顶层，在包指令之前或在所有导入之前，如果文件位于默认包中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@file:JvmName</span>(<span class="string">"KotlinAnnotationKt"</span>)</div><div class="line"></div><div class="line"><span class="keyword">package</span> demo</div></pre></td></tr></table></figure><p>如果要指定精确地指定应该如何生成该注解，请使用以下语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@处目标元素:[注解A 注解B ] ... <span class="comment">//同一目标只有1个注解时方括号可以省略</span></div></pre></td></tr></table></figure><p>简单示例如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="meta">@field:FieldScope</span> <span class="keyword">val</span> name: String, <span class="meta">@get:</span>[ApplicationScope FunScope] <span class="keyword">val</span> age: <span class="built_in">Int</span>)</div></pre></td></tr></table></figure><p>如果不指定使用处目标，则根据正在使用的注解的 <code>@Target</code> 注解来选择目标 。</p><h4 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h4><p>Java 注解与 Kotlin 100% 兼容：</p><p>kotlin</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明注解</span></div><div class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Targets</span></span>(<span class="keyword">vararg</span> <span class="keyword">val</span> value: KClass&lt;*&gt;)</div><div class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetArrays</span></span>(<span class="keyword">val</span> value: Array&lt;KClass&lt;*&gt;&gt;)</div><div class="line"></div><div class="line"><span class="meta">@JavaAnnotation</span>.Describe(<span class="string">"see"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">See</span></span></div><div class="line"><span class="meta">@JavaAnnotation</span>.SinceJava(name = <span class="string">"jdk"</span>, version = <span class="number">1</span>_8_0)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JDK</span></span></div><div class="line"><span class="meta">@JavaAnnotation</span>.Targets(Any::<span class="class"><span class="keyword">class</span>, <span class="type">String::class)</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Targets</span></span></div><div class="line"><span class="meta">@JavaAnnotation</span>.Targets(*arrayOf(Any::<span class="class"><span class="keyword">class</span>, <span class="type">String::class))</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Targets2</span></span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printId</span><span class="params">(intId: <span class="type">JavaAnnotation</span>.<span class="type">IntId</span>)</span></span> &#123;</div><div class="line">    println(intId.value)</div><div class="line">&#125;</div><div class="line"><span class="meta">@JavaAnnotation</span>.IntId(<span class="built_in">Int</span>.MAX_VALUE)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Res</span></span></div><div class="line">printId(Res::<span class="class"><span class="keyword">class</span>.<span class="title">annotations</span>[0] <span class="title">as</span> <span class="title">JavaAnnotation</span>.<span class="title">IntId</span>)</span></div></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@KotlinAnnotation</span>.ApplicationScope</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaAnnotation</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class clazz = Class.forName(<span class="string">"jsource.JavaAnnotation"</span>);</div><div class="line">            Annotation annotation = clazz.getAnnotation(KotlinAnnotation.ApplicationScope.class);</div><div class="line">            System.out.println(annotation);</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@KotlinAnnotation</span>.Targets(&#123;String.class, Integer.class&#125;)</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@KotlinAnnotation</span>.TargetArrays(&#123;String.class, Integer.class&#125;)</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TargetArrays</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Describe &#123;</div><div class="line">        <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> SinceJava &#123;</div><div class="line">        <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">version</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Targets &#123;</div><div class="line">        Class[] value();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> IntId &#123;</div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>与 Java 类似，Kotlin 中的泛型,如下示例:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> emptyListString = List&lt;String&gt;()</div><div class="line">    <span class="keyword">val</span> listString = List(<span class="string">"C"</span>, <span class="string">"D"</span>)</div><div class="line">    assertEquals(<span class="number">0</span>, emptyListString.size, <span class="string">"empty"</span>)</div><div class="line">    printList(listString)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//泛型类</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">vararg</span> elements: T) : Iterable&lt;T&gt; &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;T&gt; &#123;</div><div class="line">        <span class="keyword">return</span> elementsArray.iterator()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> elementsArray = mutableListOf(*elements)</div><div class="line"></div><div class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T = elementsArray[index]</div><div class="line"></div><div class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span> = elementsArray.size</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 泛型方法 printList</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> <span class="title">printList</span><span class="params">(inputList: <span class="type">List</span>&lt;<span class="type">E</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> inputList) &#123;</div><div class="line">        println(<span class="string">"<span class="subst">$element</span> "</span>)</div><div class="line">    &#125;</div><div class="line">    println()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与 Java 不同，Kotlin 中的泛型没有通配符类型，它有：声明处型变（declaration-site variance）与类型投影（type projections）。</p><h4 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h4><p>Java 中的泛型是<strong>不型变的</strong>，这意味着 <code>List&lt;String&gt;</code> 并<strong>不是</strong><code>List&lt;Object&gt;</code> 的子类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; strs = new ArrayList&lt;String&gt;();</div><div class="line">List&lt;Object&gt; objs =(List) strs;</div><div class="line">objs.add(<span class="number">1</span>);</div><div class="line">String s = strs.<span class="keyword">get</span>(<span class="number">0</span>); <span class="comment">// ！！！ ClassCastException：无法将整数转换为字符串</span></div></pre></td></tr></table></figure><p>PECS原则,在Java <code>&lt;? extends T&gt;、&lt;? super T&gt;</code> <strong>通配符类型参数</strong>,前者只能读取, 不能写入,后者反之。便有一条规律，”Producer Extends, Consumer Super”：</p><ul><li><code>Producer Extends</code> – 如果你需要一个只读List，用它来produce T，那么使用<code>? extends T</code>。</li><li><code>Consumer Super</code> – 如果你需要一个只写List，用它来consume T，那么使用<code>? super T</code>。</li><li>如果需要同时读取以及写入，那么我们就不能使用通配符了。</li></ul><p>同样PECS原则适用于 Kotlin:</p><ul><li><code>Producer Extends</code> –  使得类型是<strong>协变的（covariant）</strong>。</li><li><code>Consumer Super</code> –  使得类型是<strong>逆变性（contravariance）</strong>。</li></ul><p>NOTE: <em>PECS 代表生产者-Extens，消费者-Super（Producer-Extends, Consumer-Super）。</em>一个生产者对象，只是保证<strong>类型安全</strong>。</p><h4 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h4><p>Java 中<code>List&lt;String&gt;</code> 不能直接赋值<code>List&lt;Object&gt;</code> ,在 Kotlin 中，提供 <strong>out</strong> 修饰符确保接口或类成员中<strong>返回</strong><code>out</code>（生产），并从不被 <code>in</code> (消费)。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> stringList = listOf&lt;String&gt;()</div><div class="line"><span class="keyword">val</span> anyList: List&lt;Any&gt; = stringList</div></pre></td></tr></table></figure><p>kotlin List 接口声明:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="type">out E</span>&gt; : <span class="type">Collection</span>&lt;<span class="type">E</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>in</strong>。它使得一个类型参数<strong>逆变</strong>：只可以被消费而不可以被生产。逆变类的一个很好的例子是 <code>Comparable</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">abstract class Comparable&lt;in T&gt; &#123;</div><div class="line">    abstract fun compareTo(other: T): Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun demo(x: Comparable&lt;Number&gt;) &#123;</div><div class="line">    x.compareTo(1.0) // 1.0 拥有类型 Double，它是 Number 的子类型</div><div class="line">    // 因此，我们可以将 x 赋给类型为 Comparable &lt;Double&gt; 的变量</div><div class="line">    val y: Comparable&lt;Double&gt; = x // OK！</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>类型参数 <code>T</code> 被声明为 <strong>out</strong> 时，虽然 <code>**&lt;Base&gt;</code> 可以安全地作为 <code>**&lt;Derived&gt;</code>的超类, 就只能出现<strong>输出</strong>-位置。</p><p>因为它在类型参数声明处提供，所以被称做<strong>声明处型变</strong>。 这与 Java 的<strong>使用处型变</strong>相反，其类型用途通配符使得类型协变。<strong>in</strong> 反之。</p><p><strong>NOTE：消费者 in, 生产者 out </strong></p><h4 id="类型投影-使用处型变"><a href="#类型投影-使用处型变" class="headerlink" title="类型投影 (使用处型变)"></a>类型投影 (使用处型变)</h4><p>将类型参数 T 声明为 <strong>out</strong> 非常方便，并且能避免使用处子类型化的麻烦，但是有些类实际上<strong>不能</strong>限制为只返回 <code>T</code>  比如 Array：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ints: Array&lt;<span class="keyword">out</span> <span class="built_in">Int</span>&gt; = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> any = Array&lt;Any&gt;(<span class="number">3</span>) &#123; <span class="string">""</span> &#125;</div><div class="line"><span class="comment">//out 生产者 相当于Java ? extends T</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> from.indices) &#123;</div><div class="line">        to[index] = from[index]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">copy(from = ints, to = any)</div><div class="line"><span class="keyword">for</span> (items <span class="keyword">in</span> any) &#123;</div><div class="line">    println(items)</div><div class="line">&#125;</div><div class="line"><span class="comment">//out 消费者 相当于Java ? super T</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fill</span><span class="params">(dest: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">Int</span>&gt;, value: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> dest.indices) &#123;</div><div class="line">        dest[index] = (dest[index] <span class="keyword">as</span>? <span class="built_in">Int</span>)!!.times(value)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">fill(any, <span class="number">2</span>)</div><div class="line"><span class="keyword">for</span> (items <span class="keyword">in</span> any) &#123;</div><div class="line">    println(items)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面<strong>out in 类型投影</strong>, 也就是Java 的使用处型变 <code>? [extends][super] T</code> </p><h4 id="星投影"><a href="#星投影" class="headerlink" title="星投影"></a>星投影</h4><p>若类型参数一无所知，但仍然希望以安全的方式使用它。 这里的安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化将是该投影的子类型。</p><p>Kotlin 为此提供了所谓的<strong>星投影</strong>语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> star: List&lt;*&gt; = listOf(<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="keyword">val</span> any1: Any? = star[<span class="number">0</span>]</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">compareTo2</span><span class="params">(x: <span class="type">Comparable</span>&lt;*&gt;)</span></span></div></pre></td></tr></table></figure><ul><li>对于 <code>Foo &lt;out T&gt;</code>，其中 <code>T</code> 是一个具有上界 <code>TUpper</code> 的协变类型参数，<code>Foo &lt;*&gt;</code> 等价于 <code>Foo &lt;out TUpper&gt;</code>。 这意味着当 <code>T</code> 未知时，你可以安全地从 <code>Foo &lt;*&gt;</code> <em>读取</em> <code>TUpper</code> 的值。</li><li>对于 <code>Foo &lt;in T&gt;</code>，其中 <code>T</code> 是一个逆变类型参数，<code>Foo &lt;*&gt;</code> 等价于 <code>Foo &lt;in Nothing&gt;</code>。 这意味着当 <code>T</code> 未知时，没有什么可以以安全的方式<em>写入</em> <code>Foo &lt;*&gt;</code>。</li><li>对于 <code>Foo &lt;T&gt;</code>，其中 <code>T</code> 是一个具有上界 <code>TUpper</code> 的不型变类型参数，<code>Foo&lt;*&gt;</code> 对于读取值时等价于 <code>Foo&lt;out TUpper&gt;</code> 而对于写值时等价于 <code>Foo&lt;in Nothing&gt;</code>。</li></ul><p>如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 <code>interface Function &lt;in T, out U&gt;</code>，我们可以想象以下星投影：</p><ul><li><code>Function&lt;*, String&gt;</code> 表示 <code>Function&lt;in Nothing, String&gt;</code>；</li><li><code>Function&lt;Int, *&gt;</code> 表示 <code>Function&lt;Int, out Any?&gt;</code>；</li><li><code>Function&lt;*, *&gt;</code> 表示 <code>Function&lt;in Nothing, out Any?&gt;</code>。</li></ul><p><em>注意</em>：星投影非常像 Java 的原始类型，但是安全。</p><h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>能够替换给定类型参数的所有可能类型的集合可以由<strong>泛型约束</strong>限制。</p><p>最常见的约束类型是与 Java 的 <em>extends</em> 关键字对应的 <strong>上界</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Number&gt;</span> <span class="title">add</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</div><div class="line">    <span class="comment">// ……</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="number">1</span>)</div><div class="line">add(<span class="string">""</span>) <span class="comment">//not allow</span></div></pre></td></tr></table></figure><p>默认的上界（如果没有声明）是 <code>Any?</code>。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，我们需要一个单独的 <strong>where</strong>-子句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cloneWhenGreater</span><span class="params">(t: <span class="type">T</span>)</span></span></div><div class="line">        where T : Number,</div><div class="line">              <span class="comment">//              T : String, 只指定一个class ,接口可以多个</span></div><div class="line">              T : kotlin.Comparable&lt;T&gt;,</div><div class="line">              T : Cloneable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>Kotlin 同 C# 和 Gosu 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。 这通过叫做 <strong>扩展</strong> 的特殊声明完成。Kotlin 支持 <strong>扩展函数</strong> 和 <strong>扩展属性</strong>。</p><h4 id="扩展函数和属性"><a href="#扩展函数和属性" class="headerlink" title="扩展函数和属性"></a>扩展函数和属性</h4><p>声明一个扩展函数和属性，我们需要用一个 <strong>接收者类型</strong> 也就是被扩展的类型来作为他的前缀。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinExtension</span> </span>&#123;</div><div class="line">    <span class="comment">//成员函数比扩展函数优先</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">member</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"call#member"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fileName</span><span class="params">()</span></span>: String &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"KotlinExtension.class"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//扩展的对象类型 KotlinExtension</span></div><div class="line"><span class="function"><span class="keyword">fun</span> KotlinExtension.<span class="title">extensionFun</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"this@<span class="subst">$&#123;this&#125;</span> call#extensionFun"</span>) <span class="comment">//</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> KotlinExtension.<span class="title">member</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"call#extension"</span>) <span class="comment">//</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//接收者类型表达式中使用泛型 要在函数名前声明泛型参数</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> List<span class="type">&lt;E&gt;</span>.<span class="title">addAll</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//扩展属性(Extension Property)  实际扩展get* 函数而已</span></div><div class="line"><span class="keyword">val</span> KotlinExtension.fileName</div><div class="line">    <span class="keyword">get</span>() = <span class="string">"KotlinExtension.kt"</span></div></pre></td></tr></table></figure><p>NOTE: <strong>this</strong> 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象）</p><h4 id="可空接收者"><a href="#可空接收者" class="headerlink" title="可空接收者"></a>可空接收者</h4><p>可空的接收者类型也能定义扩展，在对象变量上调用值为 null时，并且可以在函数体内检测 <code>this == null</code>，</p><p>检测发生在扩展函数的内部。最好的例子,如 Library.kt中:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> Any?.<span class="title">toString</span><span class="params">()</span></span>: String</div></pre></td></tr></table></figure><h4 id="伴生对象的扩展"><a href="#伴生对象的扩展" class="headerlink" title="伴生对象的扩展"></a>伴生对象的扩展</h4><p>伴生对象的扩展和定义扩展函数和属性一致:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> KotlinExtension.Companion.anProperty: <span class="built_in">Int</span> <span class="keyword">get</span>() = <span class="number">1</span></div><div class="line"><span class="function"><span class="keyword">fun</span> KotlinExtension.Companion.<span class="title">extensionFun</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"call#Companion.extensionFun"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="扩展的作用域"><a href="#扩展的作用域" class="headerlink" title="扩展的作用域"></a>扩展的作用域</h4><p>大多数在顶层定义扩展，要使用所定义包之外的一个扩展，导包就可以使用它。类内部也可以声明扩展（我认为这并无卵用）在这样的扩展内部，该类的对象和接收者的对象成员，自由访问。扩展声明所在的类的实例称为 <strong>分发接收者</strong>，扩展方法调用所在的接收者类型的实例称为 <strong>扩展接收者</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinInteriorExtension</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"call#start"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> KotlinExtension.<span class="title">stop</span><span class="params">()</span></span>&#123;</div><div class="line">        start()</div><div class="line">        member() <span class="comment">//扩展声明为成员时 扩展函数优先</span></div><div class="line">        <span class="keyword">this</span><span class="symbol">@KotlinInteriorExtension</span>.member() <span class="comment">//使用 限定this</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">member</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"call#member"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="扩展是静态解析的"><a href="#扩展是静态解析的" class="headerlink" title="扩展是静态解析的"></a>扩展是静态解析的</h4><p>谨记扩展不能真正的修改他们所扩展的类， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。</p><p>扩展函数是静态分发的，是由函数调用所在的表达式的类型来决定。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//扩展是静态解析的</span></div><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBookmark</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloudBookmark</span> : <span class="type">LocalBookmark</span></span>()</div><div class="line"></div><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBookmarkManage</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> LocalBookmark.<span class="title">sync</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"syncToCloud"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> CloudBookmark.<span class="title">sync</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"syncFromCloud"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">syncLocal</span><span class="params">(localBookmark: <span class="type">LocalBookmark</span>)</span></span> &#123;</div><div class="line">        localBookmark.sync()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloudBookmarkManage</span> : <span class="type">LocalBookmarkManage</span></span>() &#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> LocalBookmark.<span class="title">sync</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"syncFromLocal"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> CloudBookmark.<span class="title">sync</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"syncToLocal"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//run</span></div><div class="line">LocalBookmarkManage().syncLocal(localBookmark) <span class="comment">//输出 syncToCloud</span></div><div class="line">CloudBookmarkManage().syncLocal(cloudBookmark) <span class="comment">//输出 syncFromLocal —— 分发接收者虚拟解析</span></div><div class="line"></div><div class="line">LocalBookmarkManage().syncLocal(cloudBookmark)<span class="comment">//输出 syncToCloud —— 扩展接收者静态解析</span></div><div class="line">CloudBookmarkManage().syncLocal(localBookmark)<span class="comment">//输出 syncFromLocal —— 分发接收者虚拟解析</span></div></pre></td></tr></table></figure><p>函数的分发对于分发接收者类型是虚拟的，但对于扩展接收者类型一定是静态的。</p><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>kotlin 支持委托类和属性, 使用关键字 <code>by</code> . </p><h4 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPrinter</span> : <span class="type">Printer &#123;</span></span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"ColorPrinter#print"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackPrinter</span> : <span class="type">Printer &#123;</span></span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"BlackPrinter#print"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipurposePrinter</span></span>(<span class="keyword">val</span> printer: Printer) : Printer <span class="keyword">by</span> printer &#123;</div><div class="line">    <span class="comment">//可覆盖 , 不覆盖转发printer print 方法</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</div><div class="line">        printer.print()</div><div class="line">        println(<span class="string">"override#print"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    MultipurposePrinter(ColorPrinter()).print()</div><div class="line">    MultipurposePrinter(BlackPrinter()).print()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>by xxa</code> -子句表示<code>xxa</code> 将会在 类中内部存储。 并且编译器将生成转发给 <code>xxa</code> 的所有成员函数。</p><h4 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h4><p>kotlin 标准库实现如下常见的属性类型:</p><ul><li>延迟属性（lazy properties）: 其值只在首次访问时计算，</li><li>可观察属性（observable properties）: 监听器会收到有关此属性变更的通知，</li><li>把多个属性储存在一个映射（map）中，而不是每个存在单独的字段中。</li></ul><h5 id="延迟属性-Lazy"><a href="#延迟属性-Lazy" class="headerlink" title="延迟属性 Lazy"></a>延迟属性 Lazy</h5><p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html" target="_blank" rel="external"><code>lazy()</code></a> 是接受一个 lambda 并返回一个 <code>Lazy &lt;T&gt;</code> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 <code>get()</code> 会执行已传递给 <code>lazy()</code> 的 lambda 表达式并记录结果， 后续调用 <code>get()</code> 只是返回记录的结果。</p><p>默认情况下，对于 lazy 属性的求值是<strong>同步锁的（synchronized）</strong>：该值只在一个线程中计算，并且所有线程会看到相同的值。如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 <code>LazyThreadSafetyMode.PUBLICATION</code> 作为参数传递给 <code>lazy()</code> 函数。 而如果你确定初始化将总是发生在单个线程，那么你可以使用 <code>LazyThreadSafetyMode.NONE</code> 模式， 它不会有任何线程安全的保证和相关的开销。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> lazyValue <span class="keyword">by</span> lazy&lt;String&gt;(LazyThreadSafetyMode.SYNCHRONIZED) &#123;</div><div class="line">    println(<span class="string">"computed!"</span>)</div><div class="line">    <span class="string">"Hello"</span> <span class="comment">//同步锁的（synchronized）</span></div><div class="line">&#125;</div><div class="line">println(lazyValue)</div><div class="line">println(lazyValue)</div></pre></td></tr></table></figure><p>这个例子输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">computed!</div><div class="line">Hello</div><div class="line">Hello</div></pre></td></tr></table></figure><h5 id="可观察属性-Observable"><a href="#可观察属性-Observable" class="headerlink" title="可观察属性 Observable"></a>可观察属性 Observable</h5><p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html" target="_blank" rel="external"><code>Delegates.observable()</code></a> 接受两个参数：初始值和修改时处理程序（handler）。 每当我们给属性赋值时会调用该处理程序（在赋值<em>后</em>执行）。它有三个参数：被赋值的属性、旧值和新值。</p><p>如果你想能够截获一个赋值并“否决”它，就使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html" target="_blank" rel="external"><code>vetoable()</code></a> 取代 <code>observable()</code>。 在属性被赋新值生效<em>之前</em>会调用传递给 <code>vetoable</code> 的处理程序。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name <span class="keyword">by</span> Delegates.observable(<span class="string">"No Name"</span>) &#123; prop, old, new -&gt;</div><div class="line">    println(<span class="string">"被赋值的属性：<span class="subst">$&#123;prop.name&#125;</span>,  <span class="subst">$old</span> &gt; <span class="subst">$new</span>"</span>)</div><div class="line">&#125;</div><div class="line">name = <span class="string">"両儀式"</span></div><div class="line">name = <span class="string">"式"</span></div><div class="line"><span class="keyword">var</span> skip <span class="keyword">by</span> Delegates.vetoable(<span class="string">"Null"</span>) &#123; property, oldValue, newValue -&gt;</div><div class="line">    println(<span class="string">"被赋值的属性：<span class="subst">$&#123;property.name&#125;</span>,  <span class="subst">$oldValue</span> &gt; <span class="subst">$newValue</span>"</span>)</div><div class="line">    <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">skip = <span class="string">"Test"</span></div><div class="line">println(skip)</div></pre></td></tr></table></figure><p>这个例子输出：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">被赋值的属性：name,  No Name &gt; 両儀式</div><div class="line">被赋值的属性：name,  両儀式 &gt; 式</div><div class="line">被赋值的属性：skip,  Null &gt; Test</div><div class="line">Null</div></pre></td></tr></table></figure><h5 id="把属性储存在映射中"><a href="#把属性储存在映射中" class="headerlink" title="把属性储存在映射中"></a>把属性储存在映射中</h5><p>Map 可作为委托来实现委托属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> languageMap = mapOf(<span class="string">"language"</span> to <span class="string">"kotlin"</span>)</div><div class="line"><span class="keyword">val</span> language <span class="keyword">by</span> languageMap <span class="comment">//变量名就是map的key 否则找不到该key Exception: NoSuchElementException</span></div><div class="line">println(language)</div></pre></td></tr></table></figure><p>若要 <code>var</code> 属性只需要使用 <code>MutableMap</code> 。同样也适用于类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(map: Map&lt;String, Any?&gt;) &#123;</div><div class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</div><div class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span>     <span class="keyword">by</span> map</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">make</span><span class="params">()</span></span> &#123;</div><div class="line">        println(<span class="string">"make"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">enable</span><span class="params">()</span></span> = <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> user = User(mapOf(</div><div class="line">        <span class="string">"name"</span> to <span class="string">"John Doe"</span>,</div><div class="line">        <span class="string">"age"</span> to <span class="number">25</span></div><div class="line">))</div><div class="line">println(<span class="string">"<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.age&#125;</span>"</span>)<span class="comment">//ok</span></div></pre></td></tr></table></figure><h5 id="局部委托属性"><a href="#局部委托属性" class="headerlink" title="局部委托属性"></a>局部委托属性</h5><p>what? 看 <code>lazy()</code> 强大的初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">letMake</span><span class="params">(take: ()</span></span> -&gt; User) &#123;</div><div class="line">    <span class="keyword">val</span> lazyUser <span class="keyword">by</span> lazy(take)</div><div class="line">    <span class="comment">//todo change true</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">false</span> &amp;&amp; lazyUser.enable()) &#123;</div><div class="line">        lazyUser.make()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//... </span></div><div class="line">letMake &#123; -&gt;</div><div class="line">    println(<span class="string">"init"</span>)</div><div class="line">    User(mapOf(<span class="string">"Twins"</span> to <span class="number">17</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h5><p> <strong>var</strong> 属性需要实现  <code>getValue()</code>  <code>setValue()</code>  函数,<strong>val</strong> 只是需要<code>getValue()</code> 即可。两函数都需要用 <code>operator</code> 关键字来进行标记。</p><p>委托类还可以实现包含所需 <code>operator</code> 方法的 <code>ReadOnlyProperty</code> 或 <code>ReadWriteProperty</code> 接口之一。 这俩接口是在 Kotlin 标准库中声明的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">$thisRef</span>, thank you for delegating '<span class="subst">$&#123;property.name&#125;</span>' to me!"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"<span class="subst">$value</span> has been assigned to '<span class="subst">$&#123;property.name&#125;</span> in <span class="subst">$thisRef</span>.'"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadDelegate</span> : <span class="type">ReadOnlyProperty</span>&lt;<span class="type">Any?, String</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">$thisRef</span>, thank you for delegating '<span class="subst">$&#123;property.name&#125;</span>' to me!"</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//不需要 setValue</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//test</span></div><div class="line"><span class="keyword">var</span> p: String  <span class="keyword">by</span> Delegate()</div><div class="line">p = <span class="string">"default"</span></div><div class="line">p = <span class="string">"<span class="subst">$p</span>  \nchange"</span></div><div class="line"><span class="keyword">val</span> read <span class="keyword">by</span> ReadDelegate()</div><div class="line">println(read)</div></pre></td></tr></table></figure><h5 id="背后原理"><a href="#背后原理" class="headerlink" title="背后原理"></a>背后原理</h5><p>在使用委托的时, 不难发现该属性是委托类型。比如： <code>p is String</code> ,输出false。</p><p>在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 <code>prop</code>，生成隐藏属性 <code>prop$delegate</code>，而访问器的代码只是简单地委托给这个附加属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> prop: Type <span class="keyword">by</span> MyDelegate()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这段是由编译器生成的相应代码：</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> prop$delegate = MyDelegate()</div><div class="line">    <span class="keyword">var</span> prop: Type</div><div class="line">        <span class="keyword">get</span>() = prop$delegate.getValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop)</div><div class="line">        <span class="keyword">set</span>(value: Type) = prop$delegate.setValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop, value)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> Kotlin 编译器在参数中提供了关于 <code>prop</code> 的所有必要信息：第一个参数 <code>this</code> 引用到外部类 <code>C</code> 的实例而 <code>this::prop</code> 是 <code>KProperty</code> 类型的反射对象，该对象描述 <code>prop</code> 自身。</p><h5 id="提供委托"><a href="#提供委托" class="headerlink" title="提供委托"></a>提供委托</h5><p>kotlin 提供 <code>provideDelegate</code> 操作符，可以扩展创建属性实现所委托对象的逻辑。使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span> </span>&#123;</div><div class="line">  <span class="keyword">object</span> id &#123;</div><div class="line">    <span class="keyword">val</span> textView = <span class="number">0x003</span></div><div class="line">    <span class="keyword">val</span> imageView = <span class="number">0x004</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">object</span> string &#123;</div><div class="line">    <span class="keyword">val</span> hello_world = <span class="number">0x001</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">object</span> drawable &#123;</div><div class="line">    <span class="keyword">val</span> icon_launch = <span class="number">0x002</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>)</div><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageView</span></span>(id: <span class="built_in">Int</span>) : View(id)</div><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span></span>(id: <span class="built_in">Int</span>, <span class="keyword">var</span> text: String = <span class="string">""</span>) : View(id)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> helloWorld <span class="keyword">by</span> findResourceById&lt;String&gt;(R.string.hello_world)</div><div class="line">  <span class="keyword">val</span> textView <span class="keyword">by</span> findResourceById&lt;TextView&gt;(R.id.textView)</div><div class="line"></div><div class="line">  <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">findResourceById</span><span class="params">(id: <span class="type">Int</span>)</span></span>: ResourceLoader&lt;T&gt; &#123;</div><div class="line">    <span class="keyword">return</span> ResourceLoader&lt;T&gt;(id)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</div><div class="line">    println(helloWorld)</div><div class="line">    textView.text = <span class="string">"Hello"</span></div><div class="line">    println(textView.text)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceLoader</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) &#123;</div><div class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">provideDelegate</span><span class="params">(</span></span></div><div class="line">    thisRef: <span class="type">MyActivity</span>,</div><div class="line">    prop: <span class="type">KProperty</span>&lt;*&gt;</div><div class="line">  ): ReadOnlyProperty&lt;MyActivity, T&gt; &#123;</div><div class="line">    <span class="keyword">return</span> ResDelegate&lt;T&gt;(id)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResDelegate</span>&lt;<span class="type">out V</span>&gt;</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) : ReadOnlyProperty&lt;MyActivity, V&gt; &#123;</div><div class="line">    <span class="keyword">val</span> cacheKProperty = mutableMapOf&lt;String, Any&gt;()</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">MyActivity</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V &#123;</div><div class="line">      <span class="keyword">val</span> last = cacheKProperty[property.name]</div><div class="line">      <span class="keyword">if</span> (last != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> last <span class="keyword">as</span> V</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">val</span> value = <span class="keyword">when</span> (property.returnType.classifier) &#123;</div><div class="line">        String::<span class="class"><span class="keyword">class</span> -&gt; <span class="title">property</span>.<span class="title">name</span> <span class="title">as</span> <span class="title">V</span></span></div><div class="line">        View::<span class="class"><span class="keyword">class</span> -&gt; <span class="title">View</span></span>(id) <span class="keyword">as</span> V</div><div class="line">        TextView::<span class="class"><span class="keyword">class</span> -&gt; <span class="title">TextView</span></span>(id) <span class="keyword">as</span> V</div><div class="line">        ImageView::<span class="class"><span class="keyword">class</span> -&gt; <span class="title">ImageView</span></span>(id) <span class="keyword">as</span> V</div><div class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> NoSuchElementException()</div><div class="line">      &#125;</div><div class="line">      cacheKProperty.put(property.name, value!!)</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>提供委托, 并不复杂。通过一个函数去获取委托而已。<code>provideDelegate</code> 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h3><p>Kotlin 中的函数使用 <code>fun</code> 关键字声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">funName</span><span class="params">(参数)</span></span>[: returnType(默认 <span class="built_in">Unit</span>)] ...</div></pre></td></tr></table></figure><h4 id="函数参数规则"><a href="#函数参数规则" class="headerlink" title="函数参数规则"></a>函数参数规则</h4><ul><li>函数参数使用 Pascal 表示法定义，即 <em>name</em>: <em>type</em> , 参数用逗号隔开。</li><li>每个参数必须有显式类型, 参数还可以有默认值，当省略相应的参数时使用默认值, 以减少重载数量。</li><li>覆盖带有默认参数值的方法时，默认参数值省略。</li><li>如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用<a href="https://www.kotlincn.net/docs/reference/functions.html#命名参数" target="_blank" rel="external">命名参数</a>调用该函数来使用</li><li>如果最后一个 <a href="https://www.kotlincn.net/docs/reference/lambdas.html#lambda-表达式与匿名函数" target="_blank" rel="external">lambda 表达式</a>参数从括号外传给函数函数调用，那么允许默认参数不传值</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(method: <span class="type">String</span>, invoke: <span class="type">Any</span> = this)</span></span> &#123;</div><div class="line">  println(<span class="string">"call#method= <span class="subst">$method</span> <span class="subst">$invoke</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invokeWithNameParameter</span><span class="params">(status: <span class="type">Int</span> = <span class="number">0</span>, method: <span class="type">String</span>, invoke: <span class="type">Any</span> = this)</span></span> &#123;</div><div class="line">  println(<span class="string">"call#method= <span class="subst">$method</span> <span class="subst">$invoke</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">invokeWithLambda</span><span class="params">(status: <span class="type">Int</span> = <span class="number">0</span>, method: <span class="type">String</span> = <span class="string">"invokeWithLambda"</span>, invoke: <span class="type">Any</span> = this, apply: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  println(<span class="string">"call#method= <span class="subst">$method</span> <span class="subst">$invoke</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</div><div class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(b: <span class="type">Array</span>&lt;<span class="type">Byte</span>&gt;, off: <span class="type">Int</span> = <span class="number">0</span>, len: <span class="type">Int</span> = b.size)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSource</span> : <span class="type">Source</span></span>() &#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(b: <span class="type">Array</span>&lt;<span class="type">Byte</span>&gt;, off: <span class="type">Int</span>, len: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"b.length = <span class="subst">$&#123;b.size&#125;</span> off = <span class="subst">$off</span> len = <span class="subst">$len</span>"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//test</span></div><div class="line">invoke(<span class="string">"invoke"</span>)</div><div class="line">invokeWithNameParameter(method = <span class="string">"invokeWithNameParameter"</span>)</div><div class="line">invokeWithLambda(status = <span class="number">1</span>) &#123; println(<span class="string">"invokeWithLambda"</span>) &#125;</div><div class="line">invokeWithLambda &#123; println(<span class="string">"invokeWithLambda"</span>) &#125;</div><div class="line">FileSource().read(arrayOf(<span class="string">'A'</span>.toByte(), <span class="string">'B'</span>.toByte()))</div></pre></td></tr></table></figure><h4 id="可变数量的参数（Varargs）"><a href="#可变数量的参数（Varargs）" class="headerlink" title="可变数量的参数（Varargs）"></a>可变数量的参数（Varargs）</h4><p>函数的参数（通常是最后一个）可以用 <code>vararg</code> 修饰符标记：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">varargFun</span><span class="params">(method: <span class="type">String</span> = <span class="string">"varargFun"</span>, <span class="keyword">vararg</span> s: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">  s.forEach &#123; print(it) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> b = intArrayOf(<span class="number">6</span>, <span class="number">8</span>)</div><div class="line"><span class="comment">// vararg 参数 类型是基本类型,即是 *Array 类型 否则 Array&lt;out T&gt;</span></div><div class="line">varargFun(<span class="string">"1"</span>, <span class="number">2</span>, <span class="number">4</span>, *b, <span class="number">10</span>)</div></pre></td></tr></table></figure><p><strong>伸展（spread）</strong>操作符（在数组前面加 <code>*</code>）,可以数组元素添加到vararg 变量中去</p><h4 id="返回-Unit-的函数"><a href="#返回-Unit-的函数" class="headerlink" title="返回 Unit 的函数"></a>返回 Unit 的函数</h4><p>如果一个函数不返回任何有用的值，它的返回类型是 <code>Unit</code>。<code>Unit</code> 是一种只有一个值——<code>Unit</code> 的类型。这个值不需要显式返回。Unit 就像Java 的 <code>Void</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printHello</span><span class="params">(name: <span class="type">String</span>?)</span></span>: <span class="built_in">Unit</span> &#123;</div><div class="line">  <span class="keyword">if</span> (name != <span class="literal">null</span>)</div><div class="line">  println(<span class="string">"Hello <span class="subst">$&#123;name&#125;</span>"</span>)</div><div class="line">  <span class="keyword">else</span></div><div class="line">  println(<span class="string">"Hi there!"</span>)</div><div class="line">  <span class="comment">// `return Unit` 或者 `return` 是可选的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="单表达式函数"><a href="#单表达式函数" class="headerlink" title="单表达式函数"></a>单表达式函数</h4><p>当函数返回单个表达式时，可以省略花括号并且在 <strong>=</strong> 符号之后指定代码体即可。当返回值类型可由编译器推断时，显式声明返回类型是<a href="https://www.kotlincn.net/docs/reference/functions.html#显式返回类型" target="_blank" rel="external">可选</a>的, 但具有块代码体的函数必须始终显式指定返回类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x * <span class="number">2</span></div></pre></td></tr></table></figure><h4 id="中缀表示法"><a href="#中缀表示法" class="headerlink" title="中缀表示法"></a>中缀表示法</h4><p>Kotlin支持数字运算的标准集,正是用了中缀表示法，当函数满足以下条件就能用 <code>infix</code> 关键字标注</p><ul><li>他们是成员函数或<a href="https://www.kotlincn.net/docs/reference/extensions.html" target="_blank" rel="external">扩展函数</a></li><li>他们只有一个参数</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">append</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">$this</span><span class="subst">$s</span>"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(method: <span class="type">String</span>)</span></span> &#123;</div><div class="line">    println(<span class="string">"call#method= <span class="subst">$method</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> s = <span class="string">"infix"</span> append <span class="string">" gc"</span></div><div class="line">println(s)</div><div class="line"><span class="keyword">this</span> call (<span class="string">"append"</span>)</div></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>在 Kotlin 中函数可以在文件顶层声明，这意味着你不需要像一些语言如 Java、C# 或 Scala 那样创建一个类来保存一个函数。此外除了顶层函数，Kotlin 中函数也可以声明在局部作用域、作为成员函数以及扩展函数。</p><ul><li>在类或对象内部定义的函数——成员函数</li><li>一个函数在另一个函数内部——局部函数</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//成员函数</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">memberFun</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">val</span> visited = <span class="string">""</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">partialFun</span><span class="params">()</span></span> &#123;    <span class="comment">//局部函数</span></div><div class="line">    println(visited)</div><div class="line">  &#125;</div><div class="line">  partialFun()</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>函数可以有泛型参数，通过在函数名前使用尖括号指定。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">singletonList</span><span class="params">(item: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</div><div class="line">  <span class="keyword">return</span> listOf(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是将函数用作参数或返回值的函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数用作参数 () -&gt; Unit 不带参数并 且返回 Unit 类型值的函数</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">post</span><span class="params">(runnable: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  println(<span class="string">"post before"</span>)</div><div class="line">  runnable()</div><div class="line">  println(<span class="string">"post after"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postDelay</span><span class="params">(delay: <span class="type">Int</span>, runnable: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  println(<span class="string">"postDelay before"</span>)</div><div class="line">  runnable()</div><div class="line">  println(<span class="string">"postDelay after"</span>)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">  post(<span class="keyword">this</span>::sayHi) <span class="comment">//函数引用</span></div><div class="line">  post &#123; println(<span class="string">"post"</span>) &#125;</div><div class="line">  postDelay(<span class="number">1000</span>) &#123; println(<span class="string">"postDelay"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>() -&gt; Unit</code> 被称为<a href="#函数类型">函数类型</a> , <code>::</code> 操作符可参见<a href="#函数引用">函数引用</a>, 当一个函数接受另一个函数作为最后一个参数，lambda 表达式参数可以在圆括号参数列表之外传递。 参见 <a href="https://www.kotlincn.net/docs/reference/grammar.html#callSuffix" target="_blank" rel="external">callSuffix</a> 的语法。</p><h4 id="Lambda-表达式与匿名函数"><a href="#Lambda-表达式与匿名函数" class="headerlink" title="Lambda 表达式与匿名函数"></a>Lambda 表达式与匿名函数</h4><p>一个 lambda 表达式或匿名函数是一个“函数字面值”，即一个未声明的函数， 作为表达式传递。</p><h5 id="Lambda-表达式语法"><a href="#Lambda-表达式语法" class="headerlink" title="Lambda 表达式语法"></a>Lambda 表达式语法</h5><p>lambda 表达式总是被大括号括着,完整语法形式的参数声明放在括号内，并有可选的类型标注， 函数体跟在一个 <code>-&gt;</code> 符号之后。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">println(&#123;&#125;) <span class="comment">//输出: () -&gt; kotlin.Unit</span></div><div class="line">println(&#123; <span class="string">"String"</span> &#125;)<span class="comment">//输出: () -&gt; kotlin.String</span></div><div class="line"><span class="keyword">val</span> string = &#123; <span class="string">"String"</span> &#125;</div><div class="line">println(string())<span class="comment">//输出: String</span></div></pre></td></tr></table></figure><p>挖槽,上面的是什么鬼。没了解<a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" target="_blank" rel="external">Lambda 表达式</a> 的，当然会困惑不已。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">explicitAnonymous</span><span class="params">()</span></span>: () -&gt; <span class="built_in">Int</span> &#123;</div><div class="line">  <span class="keyword">return</span> &#123; -&gt; <span class="number">1</span> &#125; <span class="comment">//没参数不能有括号() -&gt; 也可略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来就简单明了。<code>{}</code> 声明了个匿名函数,编译器作以下处理 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">local <span class="keyword">final</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;anonymous&gt;</span><span class="params">()</span></span>: <span class="built_in">Unit</span></div></pre></td></tr></table></figure><p>当一个空参数的匿名函数, 如 <code>{ &quot;String&quot; }</code> ,编译器会将lambda 主体中的最后一个或可能是单个）表达式会视为返回值。若是<code>{ &quot;String&quot;;1 }</code> 则输出 <code>() -&gt; kotlin.Int</code></p><p>可选的类型标注,单表达式函数时,显式声明返回类型是可选的,匿名的参数类型也是可选的。非单表达式函数时,则变量名可选。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;  <span class="comment">//val sum: (Int, Int) → Int</span></div><div class="line"><span class="keyword">val</span> sum2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x, y -&gt; x + y &#125; <span class="comment">//val sum2: (Int, Int) → Int</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum3</span><span class="params">(sum: (<span class="type">Int</span>, <span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>) &#123;</div><div class="line">  println(sum(<span class="number">0</span>,<span class="number">0</span>))</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum4</span><span class="params">(sum: (<span class="type">a</span>: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>) &#123;</div><div class="line">  println(sum)</div><div class="line">&#125;</div><div class="line">sum3 &#123; a, b -&gt; <span class="number">1</span> + <span class="number">3</span> &#125;</div><div class="line">println(sum(<span class="number">1</span>, <span class="number">2</span>))</div></pre></td></tr></table></figure><p>在 Kotlin 中Lambda表达式约定</p><ul><li>函数的最后一个参数是一个函数，并且你传递一个 lambda 表达式作为相应的参数，你可以在圆括号之外传递</li><li>lambda 是该调用的唯一参数，则调用中的圆括号可以完全省略。</li><li>函数字面值只有一个参数时， 那么它的声明可以省略（连同 <code>-&gt;</code>），其名称是 <code>it</code>。</li><li>未使用的变量可用下划线取代其名称</li><li>lambda 隐式返回最后一个表达式的值,可以用<a href="https://www.kotlincn.net/docs/reference/returns.html#标签处返回" target="_blank" rel="external">限定的返回</a>语法显式返回</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">filter</span><span class="params">(predicate: (<span class="type">T</span>)</span></span> -&gt; <span class="built_in">Boolean</span>) &#123;</div><div class="line">  TODO()</div><div class="line">&#125;</div><div class="line">filter&lt;<span class="built_in">Int</span>&gt;() &#123; it &gt; <span class="number">0</span> &#125; <span class="comment">//() 可略</span></div><div class="line">filter&lt;<span class="built_in">Int</span>&gt; &#123; it &gt; <span class="number">0</span> &#125;</div><div class="line">filter&lt;<span class="built_in">Int</span>&gt; &#123; _ -&gt; <span class="literal">false</span> &#125;</div><div class="line">filter&lt;<span class="built_in">Int</span>&gt; &#123;</div><div class="line">  <span class="keyword">val</span> shouldFilter = it &gt; <span class="number">0</span></div><div class="line">  <span class="keyword">return</span><span class="symbol">@filter</span> shouldFilter</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>顾名思义,与常规函数相同不需要指定函数名</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sumAnonymous = <span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> = x + y <span class="comment">//返回类型可以自动推断</span></div><div class="line">println(sumAnonymous(<span class="number">1</span>, <span class="number">3</span>))</div><div class="line"><span class="keyword">val</span> sumAnonymous2 = <span class="function"><span class="title">fun</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</div><div class="line">  <span class="keyword">return</span> x + y</div><div class="line">&#125;</div><div class="line">filter&lt;<span class="built_in">Int</span>&gt;(<span class="function"><span class="title">fun</span><span class="params">(item)</span></span> = item &gt; <span class="number">0</span>) <span class="comment">//推断出的参数类型可以省略. 只能在括号内传递</span></div></pre></td></tr></table></figure><p>匿名函数和lambda 是有区别的，匿名函数参数只能在括号内传递。 允许将函数留在圆括号外的简写语法仅适用于 lambda 表达式。Lambda表达式与匿名函数之间的另一个区别是<a href="https://www.kotlincn.net/docs/reference/inline-functions.html#非局部返回" target="_blank" rel="external">非局部返回</a>的行为。一个不带标签的 <em>return</em> 语句总是在用 <em>fun</em> 关键字声明的函数中返回。这意味着 lambda 表达式中的 <em>return</em> 将从包含它的函数返回，而匿名函数中的 <em>return</em>将从匿名函数自身返回。</p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>Lambda 表达式或者匿名函数（以及<a href="https://www.kotlincn.net/docs/reference/functions.html#局部函数" target="_blank" rel="external">局部函数</a>和<a href="https://www.kotlincn.net/docs/reference/object-declarations.html#对象表达式" target="_blank" rel="external">对象表达式</a>） 可以访问其 <em>闭包</em> ，即在外部作用域中声明的变量。 与 Java 不同的是可以修改闭包中捕获的变量：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aNumber = <span class="number">0</span></div><div class="line">run &#123;</div><div class="line">  aNumber += <span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">val</span> add = <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</div><div class="line">  aNumber += <span class="number">1</span></div><div class="line">&#125;</div><div class="line">add()</div><div class="line">println(<span class="string">"aNumber: <span class="subst">$aNumber</span>"</span>)</div></pre></td></tr></table></figure><h5 id="带接收者的函数字面值"><a href="#带接收者的函数字面值" class="headerlink" title="带接收者的函数字面值"></a>带接收者的函数字面值</h5><p>Kotlin 提供了使用指定的 <em>接收者对象</em> 调用函数字面值的功能。 在函数字面值的函数体中，可以调用该接收者对象上的方法而无需任何额外的限定符。 这类似于扩展函数，它允许你在函数体内访问接收者对象的成员。 其用法的最重要的示例之一是<a href="https://www.kotlincn.net/docs/reference/type-safe-builders.html" target="_blank" rel="external">类型安全的 Groovy-风格构建器</a>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sumR = <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="params">(other: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">this</span> + other <span class="comment">//val sumR: Int.(Int) → Int</span></div><div class="line">println(<span class="number">1.</span>sumR(<span class="number">2</span>))</div></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>要知道使用<a href="#高阶函数">高阶函数</a>时,每一个函数都是一个对象，且会捕获一个<a href="#闭包">闭包</a>。 所以带来一些运行时的效率损失,即那些在函数体内会访问到的变量。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。</p><p>kotlin 支持 <code>inline</code> 修饰具有lambda参数的函数,以消除这类的开销。(仅支持顶层、成员函数,即不支持局函数)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lockInline</span><span class="params">(lock: <span class="type">Lock</span>, body: ()</span></span> -&gt; T): T &#123;</div><div class="line">  lock.lock()</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> body()</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlock()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>内联原理其实是编译器拷贝代码副本（如:<code>body () -&gt; T</code>），这可能导致生成的代码增加，但在循环中的“超多态（megamorphic）” 情况下,将在性能上有所提升。</p><p>不具有lambda参数的函数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123; <span class="comment">//warn 内联函数最适用于具有lambda参数的函数</span></div></pre></td></tr></table></figure><p>NOTE：内联函数不支持局部函数</p><h4 id="禁用内联"><a href="#禁用内联" class="headerlink" title="禁用内联"></a>禁用内联</h4><p>对于具有多个lambda参数的内联函数来说，默认内联, 可用 <code>noinline</code> 修饰lambda参数,禁用内联。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(inlined: ()</span></span> -&gt; <span class="built_in">Unit</span>, <span class="keyword">noinline</span> notInlined: () -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  <span class="comment">// ……</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>noinline</code> 仅在内联函数中可使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(<span class="keyword">noinline</span> notInlined: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  <span class="comment">// …… 仅一个参数又用 noinline 修饰, inline 将无效</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="非局部返回"><a href="#非局部返回" class="headerlink" title="非局部返回"></a>非局部返回</h4><p> lambda 表达式内部不允许无标签的<code>return</code> , 但传给的函数是内联的，该 return 也可以内联，所以它是允许返回。称为<strong>非局部返回</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lock</span><span class="params">(body: ()</span></span> -&gt; T): <span class="built_in">Unit</span> &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lockInline</span><span class="params">(body: ()</span></span> -&gt; T): <span class="built_in">Unit</span> &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">lock &#123;</div><div class="line">    <span class="keyword">return</span>  <span class="comment">// 不允许不带标签的return. return@lock</span></div><div class="line">&#125;</div><div class="line">lockInline&#123;</div><div class="line">  <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>循环中常用这种结构</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasZeros</span><span class="params">(ints: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">  ints.forEach &#123;</div><div class="line">    <span class="keyword">if</span> (it == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 从 hasZeros 返回</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一些内联函数可能调用传给它们的不是直接来自函数体、而是来自另一个执行上下文的 lambda 表达式参数，例如来自局部对象或嵌套函数。在这种情况下，该 lambda 表达式中也不允许非局部控制流。为了标识这种情况，该 lambda 表达式参数需要用 <code>crossinline</code> 修饰符标记:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">post</span><span class="params">(<span class="keyword">crossinline</span> body: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">  Runnable &#123; body() &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="具体化的类型参数"><a href="#具体化的类型参数" class="headerlink" title="具体化的类型参数"></a>具体化的类型参数</h4><p>内联函数能有具体化的类型参数（Reified type parameters）,用 <code>reified</code> 修饰符来限定类型参数</p><p>在前面泛型函数学习中,是不能有具体化参数,获取 class时带来不便。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">findType</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</div><div class="line">  <span class="comment">//因为T 不是静态已知的 Kotlin 类的引用，所以不能 T::class</span></div><div class="line">  println((t <span class="keyword">as</span> Any)::<span class="class"><span class="keyword">class</span>)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//内联函数支持具体化的类型参数,不需要反射，正常的操作符如 !is 和 as 能正常使用</span></div><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Number&gt;</span> <span class="title">findReifiedType</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</div><div class="line">  println(T::<span class="class"><span class="keyword">class</span>)</span></div><div class="line">  println(<span class="built_in">Int</span>.MIN_VALUE <span class="keyword">is</span> T)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="内联属性"><a href="#内联属性" class="headerlink" title="内联属性"></a>内联属性</h4><p><code>inline</code> 修饰符还可以修饰没有幕后字段的属性的访问器（有setter/getter）,可单独标注。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> max <span class="keyword">inline</span> <span class="keyword">get</span>() = <span class="built_in">Int</span>.MAX_VALUE</div><div class="line"><span class="keyword">inline</span> <span class="keyword">val</span> max1 <span class="keyword">get</span>() = <span class="built_in">Int</span>.MAX_VALUE</div><div class="line"><span class="keyword">inline</span> <span class="keyword">val</span> max2 <span class="keyword">inline</span> <span class="keyword">get</span>() = <span class="built_in">Int</span>.MAX_VALUE <span class="comment">//编译也ok 。。。</span></div><div class="line"></div><div class="line"><span class="comment">//Inline property cannot have backing field</span></div><div class="line"><span class="keyword">var</span> count = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> counter</div><div class="line"><span class="keyword">inline</span> <span class="keyword">get</span>() = count <span class="comment">//set/get 其中一个标注为inline, 都不能使用 backing field</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">set</span>(value) &#123;</div><div class="line">  count = value</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">var</span> doubleCounter</div><div class="line"><span class="keyword">get</span>() = count * <span class="number">2</span> <span class="comment">//set/get 其中一个标注为inline, 都不能使用 backing field</span></div><div class="line"><span class="keyword">set</span>(value) &#123;</div><div class="line">  count *= value</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="公有-API-内联函数的限制"><a href="#公有-API-内联函数的限制" class="headerlink" title="公有 API 内联函数的限制"></a>公有 API 内联函数的限制</h4><p>当一个内联函数是 <code>public</code> 或 <code>protected</code> 而不是 <code>private</code> 或 <code>internal</code> 声明的一部分时，就会认为它是一个<a href="https://www.kotlincn.net/docs/reference/visibility-modifiers.html#模块" target="_blank" rel="external">模块级</a>的公有 API。可以在其他模块中调用它，并且也可以在调用处内联这样的调用。</p><p>这带来了一些由模块做这样变更时导致的二进制兼容的风险——声明一个内联函数但调用它的模块在它修改后并没有重新编译。</p><p>为了消除这种由<strong>非</strong>公有 API 变更引入的不兼容的风险，公有 API 内联函数体内不允许使用非公有声明，即，不允许使用 <code>private</code> 与 <code>internal</code> 声明以及其部件。</p><p>一个 <code>internal</code> 声明可以由 <code>@PublishedApi</code> 标注，这会允许它在公有 API 内联函数中使用。当一个 <code>internal</code> 内联函数标记有 <code>@PublishedApi</code> 时，也会像公有函数一样检查其函数体。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//公有 API 内联函数限制使用private 与 internal 声明以及其部件 （顶层声明）</span></div><div class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">publishApi</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">    privateFun()</div><div class="line">    internalFun()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@PublishedApi</span> <span class="comment">//检查其函数体加以限制</span></div><div class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">internalApi</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">    privateFun()</div><div class="line">    internalFun()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">privateFun</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">internalFun</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Kotlin与-Java-混合开发"><a href="#Kotlin与-Java-混合开发" class="headerlink" title="Kotlin与 Java 混合开发"></a>Kotlin与 Java 混合开发</h2><h3 id="Kotlin-中调用-Java"><a href="#Kotlin-中调用-Java" class="headerlink" title="Kotlin 中调用 Java"></a>Kotlin 中调用 Java</h3><h4 id="已映射类型"><a href="#已映射类型" class="headerlink" title="已映射类型"></a>已映射类型</h4><p>在Kotlin 中使用Java 代码，编译期间， Java 的原生类型映射到相应的 Kotlin 类型，运行时表示保持不变。</p><table><thead><tr><th><strong>Kotlin 类型</strong></th><th><strong>Java 类型</strong></th></tr></thead><tbody><tr><td>kotlin.Byte</td><td>byte</td></tr><tr><td>kotlin.Short</td><td>short</td></tr><tr><td>kotlin.Int</td><td>int</td></tr><tr><td>kotlin.Long</td><td>long</td></tr><tr><td>kotlin.Char</td><td>char</td></tr><tr><td>kotlin.Float</td><td>float</td></tr><tr><td>kotlin.Double</td><td>double</td></tr><tr><td>kotlin.Boolean</td><td>boolean</td></tr></tbody></table><p>Java 的装箱原始类型映射到可空的 Kotlin 类型：</p><table><thead><tr><th><strong>Kotlin 类型</strong></th><th><strong>Java 类型</strong></th></tr></thead><tbody><tr><td>kotlin.Byte?</td><td>java.lang.Byte</td></tr><tr><td>kotlin.Short？</td><td>java.lang. Short</td></tr><tr><td>kotlin.Int?</td><td>java.lang.Integer</td></tr><tr><td>kotlin.Long?</td><td>java.lang.Long</td></tr><tr><td>kotlin.Char?</td><td>java.lang.Character</td></tr><tr><td>kotlin.Float?</td><td>java.lang.Float</td></tr><tr><td>kotlin.Double?</td><td>java.lang.Double</td></tr><tr><td>kotlin.Boolean?</td><td>java.lang. Boolean</td></tr></tbody></table><p>一些非原生的内置类型也会作映射：</p><table><thead><tr><th><strong>Kotlin 类型</strong></th><th><strong>Java 类型</strong></th></tr></thead><tbody><tr><td>kotlin.Any!</td><td>java.lang.Object</td></tr><tr><td>kotlin.Cloneable!</td><td>java.lang.Cloneable</td></tr><tr><td>kotlin.Comparable!</td><td>java.lang.Comparable</td></tr><tr><td>kotlin.Enum!</td><td>java.lang.Enum</td></tr><tr><td>kotlin.Annotation!</td><td>java.lang.Annotation</td></tr><tr><td>kotlin.Deprecated!</td><td>java.lang.Deprecated</td></tr><tr><td>kotlin.CharSequence!</td><td>java.lang.CharSequence</td></tr><tr><td>kotlin.String!</td><td>java.lang.String</td></tr><tr><td>kotlin.Number!</td><td>java.lang.Number</td></tr><tr><td>kotlin.Throwable!</td><td>java.lang.Throwable</td></tr></tbody></table><p>NOTE: <code>String!</code> 为<a href="#空安全和平台类型">平台类型表示法</a></p><p>集合类型在 Kotlin 中可以是只读的或可变的，因此 Java 集合类型作如下映射： （下表中的所有 Kotlin 类型都驻留在 <code>kotlin.collections</code>包中）:</p><table><thead><tr><th>Java 类型</th><th>Kotlin 只读类型</th><th>Kotlin 可变类型</th><th>加载的平台类型</th></tr></thead><tbody><tr><td>Iterator<t></t></td><td>Iterator<t></t></td><td>MutableIterator<t></t></td><td>(Mutable)Iterator<t>!</t></td></tr><tr><td>Iterable<t></t></td><td>Iterable<t></t></td><td>MutableIterable<t></t></td><td>(Mutable)Iterable<t>!</t></td></tr><tr><td>Collection<t></t></td><td>Collection<t></t></td><td>MutableCollection<t></t></td><td>(Mutable)Collection<t>!</t></td></tr><tr><td>Set<t></t></td><td>Set<t></t></td><td>MutableSet<t></t></td><td>(Mutable)Set<t>!</t></td></tr><tr><td>List<t></t></td><td>List<t></t></td><td>MutableList<t></t></td><td>(Mutable)List<t>!</t></td></tr><tr><td>ListIterator<t></t></td><td>ListIterator<t></t></td><td>MutableListIterator<t></t></td><td>(Mutable)ListIterator<t>!</t></td></tr><tr><td>Map<k, v=""></k,></td><td>Map<k, v=""></k,></td><td>MutableMap<k, v=""></k,></td><td>(Mutable)Map<k, v="">!</k,></td></tr><tr><td>Map.Entry<k, v=""></k,></td><td>Map.Entry<k, v=""></k,></td><td>MutableMap.MutableEntry<k,v></k,v></td><td>(Mutable)Map.(Mutable)Entry<k, v="">!</k,></td></tr></tbody></table><p>请注意，用作类型参数的装箱原始类型映射到平台类型： 例如，<code>List&lt;java.lang.Integer&gt;</code> 在 Kotlin 中会成为 <code>List&lt;Int!&gt;</code>。</p><p>Java 的数组按如下所述映射：</p><table><thead><tr><th><strong>Java 类型</strong></th><th><strong>Kotlin 类型</strong></th></tr></thead><tbody><tr><td>int[]</td><td>kotlin.IntArray!</td></tr><tr><td>String[]</td><td>kotlin.Array&lt;(out) String&gt;!</td></tr></tbody></table><h4 id="空安全和平台类型"><a href="#空安全和平台类型" class="headerlink" title="空安全和平台类型"></a>空安全和平台类型</h4><p>Java 中任何引用都可能是 <code>null</code>，而Kotlin 类型安全(空安全)。 Java 声明的类型在 Kotlin 中空检查跟Java相同(可空，非空)称为<strong>平台类型</strong>。平台类型可用助记符<code>！</code>加在后面来表示,但切记不能在程序中这样写，kotlin 并没有相应语法,IDE Doc 可以显示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> nullAny = JavaDataType.nullObj <span class="comment">//实际: val nullAny: Any!</span></div><div class="line"><span class="keyword">val</span> safeNullAny: Any? = JavaDataType.nullObj</div><div class="line"></div><div class="line">println(safeNullAny?.hashCode())</div><div class="line">println(nullAny?.hashCode()) <span class="comment">//null check</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> notNullAny: Any = JavaDataType.nullObj <span class="comment">//赋值时 NPE</span></div><div class="line">nullAny.hashCode() <span class="comment">//使用时 NPE</span></div></pre></td></tr></table></figure><p>NOTE：只要不是Java基本类型,在Kotlin中都会映射为 <code>T!</code></p><h4 id="Getter-和-Setter"><a href="#Getter-和-Setter" class="headerlink" title="Getter 和 Setter"></a>Getter 和 Setter</h4><p>遵循 Java 约定的 getter 和 setter 的方法（名称以 <code>get</code> 开头的无参数方法和以 <code>set</code> 开头的单参数方法）在 Kotlin 中表示为属性。 <code>Boolean</code> 访问器方法（其中 getter 的名称以 <code>is</code> 开头而 setter 的名称以 <code>set</code> 开头）会表示为与 getter 方法具有相同名称的属性。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import java.util.Calendar</div><div class="line"></div><div class="line">fun calendarDemo() &#123;</div><div class="line">    val calendar = Calendar.getInstance()</div><div class="line">    if (calendar.firstDayOfWeek == Calendar.SUNDAY) &#123;  // 调用 getFirstDayOfWeek()</div><div class="line">        calendar.firstDayOfWeek = Calendar.MONDAY      // 调用ll setFirstDayOfWeek()</div><div class="line">    &#125;</div><div class="line">    if (!calendar.isLenient) &#123;                         // 调用 isLenient()</div><div class="line">        calendar.isLenient = true                      // 调用 setLenient()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请注意，如果 Java 类只有一个 setter，它在 Kotlin 中不会作为属性可见，因为 Kotlin 目前不支持只写（set-only）属性。</p><h4 id="返回-void-的方法"><a href="#返回-void-的方法" class="headerlink" title="返回 void 的方法"></a>返回 void 的方法</h4><p>如果一个 Java 方法返回 void，那么从 Kotlin 调用时中返回 <code>Unit</code>。 万一有人使用其返回值，它将由 Kotlin 编译器在调用处赋值， 因为该值本身是预先知道的（是 <code>Unit</code>）。</p><h4 id="将-Kotlin-中是关键字的-Java-标识符进行转义"><a href="#将-Kotlin-中是关键字的-Java-标识符进行转义" class="headerlink" title="将 Kotlin 中是关键字的 Java 标识符进行转义"></a>将 Kotlin 中是关键字的 Java 标识符进行转义</h4><p>一些 Kotlin 关键字在 Java 中是有效标识符：<em>in</em>、 <em>object</em>、 <em>is</em> 等等。 如果一个 Java 库使用了 Kotlin 关键字作为方法，你仍然可以通过反引号（`）字符转义它来调用该方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo.`<span class="keyword">is</span>`(bar)</div></pre></td></tr></table></figure><h4 id="Java-泛型"><a href="#Java-泛型" class="headerlink" title="Java 泛型"></a>Java 泛型</h4><p>Kotlin 的泛型与 Java 有点不同（参见<a href="https://www.kotlincn.net/docs/reference/generics.html" target="_blank" rel="external">泛型</a>）。当将 Java 类型导入 Kotlin 时，我们会执行一些转换：</p><ul><li>Java 的通配符转换成类型投影<ul><li><code>Foo&lt;? extends Bar&gt;</code> 转换成 <code>Foo&lt;out Bar!&gt;!</code></li><li><code>Foo&lt;? super Bar&gt;</code> 转换成 <code>Foo&lt;in Bar!&gt;!</code></li></ul></li><li>Java的原始类型转换成星投影<ul><li><code>List</code> 转换成 <code>List&lt;*&gt;!</code>，即 <code>List&lt;out Any?&gt;!</code></li></ul></li></ul><p>和 Java 一样，Kotlin 在运行时不保留泛型，即对象不携带传递到他们构造器中的那些类型参数的实际类型。 即 <code>ArrayList&lt;Integer&gt;()</code> 和 <code>ArrayList&lt;Character&gt;()</code> 是不能区分的。 这使得执行 <em>is</em>-检测不可能照顾到泛型。 Kotlin 只允许 <em>is</em>-检测星投影的泛型类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> List&lt;<span class="built_in">Int</span>&gt;) <span class="comment">// 错误：无法检查它是否真的是一个 Int 列表</span></div><div class="line"><span class="comment">// but</span></div><div class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> List&lt;*&gt;) <span class="comment">// OK：不保证列表的内容</span></div></pre></td></tr></table></figure><h4 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h4><p>java 集合类型映射的平台类型都是可变的，用法如kotlin 一样，而且 操作符约定同样有效</p><h4 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h4><p>与 Java 不同，Kotlin 中的数组是不型变的。这意味着 Kotlin 不允许我们把一个 <code>Array&lt;String&gt;</code> 赋值给一个 <code>Array&lt;Any&gt;</code>， 从而避免了可能的运行时故障。Kotlin 也禁止我们把一个子类的数组当做超类的数组传递给 Kotlin 的方法， 但是对于 Java 方法，这是允许的（通过 <code>Array&lt;(out) String&gt;!</code> 这种形式的<a href="https://www.kotlincn.net/docs/reference/java-interop.html#空安全和平台类型" target="_blank" rel="external">平台类型</a>）。</p><p>Java 平台上，数组会使用原生数据类型以避免装箱/拆箱操作的开销。 由于 Kotlin 隐藏了这些实现细节，因此需要一个变通方法来与 Java 代码进行交互。 对于每种原生类型的数组都有一个特化的类（<code>IntArray</code>、 <code>DoubleArray</code>、 <code>CharArray</code> 等等）来处理这种情况。 它们与 <code>Array</code> 类无关，并且会编译成 Java 原生类型数组以获得最佳性能。</p><p>假设有一个接受 int 数组索引的 Java 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaArrayExample</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> void removeIndices(int[] indices) &#123;</div><div class="line">        <span class="comment">// 在此编码……</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 Kotlin 中你可以这样传递一个原生类型的数组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> javaObj = JavaArrayExample()</div><div class="line"><span class="keyword">val</span> array = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">javaObj.removeIndices(array)  <span class="comment">// 将 int[] 传给方法</span></div></pre></td></tr></table></figure><p>当编译为 JVM 字节代码时，编译器会优化对数组的访问，这样就不会引入任何开销：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">array[x] = array[x] * <span class="number">2</span> <span class="comment">// 不会实际生成对 get() 和 set() 的调用</span></div><div class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> array) &#123; <span class="comment">// 不会创建迭代器</span></div><div class="line">    print(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>即使当我们使用索引定位时，也不会引入任何开销</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;<span class="comment">// 不会创建迭代器</span></div><div class="line">    array[i] += <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后，<em>in</em>-检测也没有额外开销</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> array.indices) &#123; <span class="comment">// 同 (i &gt;= 0 &amp;&amp; i &lt; array.size)</span></div><div class="line">    print(array[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Java-可变参数"><a href="#Java-可变参数" class="headerlink" title="Java 可变参数"></a>Java 可变参数</h4><p>Java 类有时声明一个具有可变数量参数（varargs）的方法来使用索引。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaArrayExample</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> void removeIndicesVarArg(int... indices) &#123;</div><div class="line">        <span class="comment">// 在此编码……</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这种情况下，你需要使用展开运算符 <code>*</code> 来传递 <code>IntArray</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> javaObj = JavaArrayExample()</div><div class="line"><span class="keyword">val</span> array = intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">javaObj.removeIndicesVarArg(*array)</div></pre></td></tr></table></figure><p>目前无法传递 <strong>null</strong> 给一个声明为可变参数的方法。</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>由于 Java 无法标记用于运算符语法的方法，Kotlin 允许具有正确名称和签名的任何 Java 方法作为运算符重载和其他约定（<code>invoke()</code> 等）使用。 不允许使用中缀调用语法调用 Java 方法。</p><h4 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h4><p>在 Kotlin 中，所有异常都是非受检的，这意味着编译器不会强迫你捕获其中的任何一个。 因此，当你调用一个声明受检异常的 Java 方法时，Kotlin 不会强迫你做任何事情：</p><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>当 Java 类型导入到 Kotlin 中时，类型 <code>java.lang.Object</code> 的所有引用都成了 <code>Any</code>。 而因为 <code>Any</code> 不是平台指定的，它只声明了 <code>toString()</code>、<code>hashCode()</code> 和 <code>equals()</code> 作为其成员， 所以为了能用到 <code>java.lang.Object</code> 的其他成员，Kotlin 要用到<a href="#扩展函数">扩展函数</a>。</p><h5 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait()/notify()"></a>wait()/notify()</h5><p><a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" target="_blank" rel="external">Effective Java</a> 第 69 条善意地建议优先使用并发工具（concurrency utilities）而不是 <code>wait()</code> 和 <code>notify()</code>。 因此，类型 <code>Any</code> 的引用不提供这两个方法。 如果你真的需要调用它们的话，你可以将其转换为 <code>java.lang.Object</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(foo <span class="keyword">as</span> java.lang.Object).wait()</div></pre></td></tr></table></figure><h5 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h5><p>要取得对象的 Java 类，请在<a href="https://www.kotlincn.net/docs/reference/reflection.html#类引用" target="_blank" rel="external">类引用</a>上使用 <code>java</code> 扩展属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> fooClass = foo::<span class="class"><span class="keyword">class</span>.<span class="title">java</span></span></div></pre></td></tr></table></figure><p>上面的代码使用了自 Kotlin 1.1 起支持的<a href="https://www.kotlincn.net/docs/reference/reflection.html#绑定的类引用自-11-起" target="_blank" rel="external">绑定的类引用</a>。你也可以使用 <code>javaClass</code> 扩展属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> fooClass = foo.javaClass</div></pre></td></tr></table></figure><h5 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h5><p>要覆盖 <code>clone()</code>，需要继承 <code>kotlin.Cloneable</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> : <span class="type">Cloneable &#123;</span></span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clone</span><span class="params">()</span></span>: Any &#123; …… &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不要忘记 <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" target="_blank" rel="external">Effective Java</a> 的第 11 条: <em>谨慎地改写clone</em>。</p><h5 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h5><p>要覆盖 <code>finalize()</code>，所有你需要做的就是简单地声明它，而不需要 <em>override</em> 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">finalize</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// 终止化逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据 Java 的规则，<code>finalize()</code> 不能是 <em>private</em> 的。</p><p>#### </p><h4 id="访问静态成员"><a href="#访问静态成员" class="headerlink" title="访问静态成员"></a>访问静态成员</h4><p>Java 类的静态成员会形成该类的“伴生对象”。我们无法将这样的“伴生对象”作为值来传递， 但可以显式访问其成员，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> character = Character</div><div class="line"><span class="keyword">if</span> (Character.isLetter(<span class="string">'A'</span>)) &#123;</div><div class="line">  <span class="comment">// ……</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h4><p>Java 反射适用于 Kotlin 类，反之亦然。如上所述，你可以使用 <code>instance::class.java</code>,<code>ClassName::class.java</code> 或者 <code>instance.javaClass</code> 通过 <code>java.lang.Class</code> 来进入 Java 反射。</p><p>其他支持的情况包括为一个 Kotlin 属性获取一个 Java 的 getter/setter 方法或者幕后字段、为一个 Java 字段获取一个 <code>KProperty</code>、为一个 <code>KFunction</code> 获取一个 Java 方法或者构造函数，反之亦然。</p><h4 id="SAM-转换"><a href="#SAM-转换" class="headerlink" title="SAM 转换"></a>SAM 转换</h4><p>就像 Java 8 一样，Kotlin 支持 SAM 转换。这意味着 Kotlin 函数字面值可以被自动的转换成只有一个非默认方法的 Java 接口的实现，只要这个方法的参数类型能够与这个 Kotlin 函数的参数类型相匹配。</p><p>你可以这样创建 SAM 接口的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val runnable = Runnable &#123; println(&quot;This runs in a runnable&quot;) &#125;</div></pre></td></tr></table></figure><p>……以及在方法调用中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val executor = ThreadPoolExecutor()</div><div class="line">// Java 签名：void execute(Runnable command)</div><div class="line">executor.execute &#123; println(&quot;This runs in a thread pool&quot;) &#125;</div></pre></td></tr></table></figure><p>如果 Java 类有多个接受函数式接口的方法，那么可以通过使用将 lambda 表达式转换为特定的 SAM 类型的适配器函数来选择需要调用的方法。这些适配器函数也会按需由编译器生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">executor.execute(Runnable &#123; println(&quot;This runs in a thread pool&quot;) &#125;)</div></pre></td></tr></table></figure><p>请注意，SAM 转换只适用于接口，而不适用于抽象类，即使这些抽象类也只有一个抽象方法。</p><p>还要注意，此功能只适用于 Java 互操作；因为 Kotlin 具有合适的函数类型，所以不需要将函数自动转换为 Kotlin 接口的实现，因此不受支持。</p><h3 id="Java中调用-Kotlin"><a href="#Java中调用-Kotlin" class="headerlink" title="Java中调用 Kotlin"></a>Java中调用 Kotlin</h3><p>Java 可以轻松调用 Kotlin 代码。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>Kotlin 属性会编译成以下 Java 元素：</p><ul><li>一个 getter 方法，名称通过加前缀 <code>get</code> 算出；</li><li>一个 setter 方法，名称通过加前缀 <code>set</code> 算出（只适用于 <code>var</code> 属性）；</li><li>一个私有字段，与属性名称相同（仅适用于具有幕后字段的属性）。</li></ul><p>例如，<code>var firstName: String</code> 编译成以下 Java 声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private String firstName;</div><div class="line"></div><div class="line">public String getFirstName() &#123;</div><div class="line">    return firstName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setFirstName(String firstName) &#123;</div><div class="line">    this.firstName = firstName;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果属性的名称以 <code>is</code> 开头，则使用不同的名称映射规则：getter 的名称与属性名称相同，并且 setter 的名称是通过将 <code>is</code> 替换为 <code>set</code> 获得。 例如，对于属性 <code>isOpen</code>，其 getter 会称做 <code>isOpen()</code>，而其 setter 会称做 <code>setOpen()</code>。 这一规则适用于任何类型的属性，并不仅限于 <code>Boolean</code>。</p><h4 id="包级函数"><a href="#包级函数" class="headerlink" title="包级函数"></a>包级函数</h4><p>在 <code>org.foo.bar</code> 包内的 <code>example.kt</code> 文件中声明的所有的函数和属性，包括扩展函数， 都编译成一个名为 <code>org.foo.bar.ExampleKt</code> 的 Java 类的静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// example.kt</div><div class="line">package demo</div><div class="line"></div><div class="line">class Foo</div><div class="line"></div><div class="line">fun bar() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">new demo.Foo();</div><div class="line">demo.ExampleKt.bar();</div></pre></td></tr></table></figure><p>可以使用 <code>@JvmName</code> 注解修改生成的 Java 类的类名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@file:JvmName(&quot;DemoUtils&quot;)</div><div class="line"></div><div class="line">package demo</div><div class="line"></div><div class="line">class Foo</div><div class="line"></div><div class="line">fun bar() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">new demo.Foo();</div><div class="line">demo.DemoUtils.bar();</div></pre></td></tr></table></figure><p>如果多个文件中生成了相同的 Java 类名（包名相同并且类名相同或者有相同的 <code>@JvmName</code> 注解）通常是错误的。然而，编译器能够生成一个单一的 Java 外观类，它具有指定的名称且包含来自所有文件中具有该名称的所有声明。 要启用生成这样的外观，请在所有相关文件中使用 @JvmMultifileClass 注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// oldutils.kt</div><div class="line">@file:JvmName(&quot;Utils&quot;)</div><div class="line">@file:JvmMultifileClass</div><div class="line"></div><div class="line">package demo</div><div class="line"></div><div class="line">fun foo() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// newutils.kt</div><div class="line">@file:JvmName(&quot;Utils&quot;)</div><div class="line">@file:JvmMultifileClass</div><div class="line"></div><div class="line">package demo</div><div class="line"></div><div class="line">fun bar() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">demo.Utils.foo();</div><div class="line">demo.Utils.bar();</div></pre></td></tr></table></figure><h4 id="实例字段"><a href="#实例字段" class="headerlink" title="实例字段"></a>实例字段</h4><p>如果需要在 Java 中将 Kotlin 属性作为字段暴露，那就需要使用 <code>@JvmField</code> 注解对其标注。 该字段将具有与底层属性相同的可见性。如果一个属性有幕后字段（backing field）、非私有、没有 <code>open</code> /<code>override</code> 或者 <code>const</code>修饰符并且不是被委托的属性，那么你可以用 <code>@JvmField</code> 注解该属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class C(id: String) &#123;</div><div class="line">    @JvmField val ID = id</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">class JavaClient &#123;</div><div class="line">    public String getID(C c) &#123;</div><div class="line">        return c.ID;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="https://www.kotlincn.net/docs/reference/properties.html#延迟初始化属性" target="_blank" rel="external">延迟初始化的</a>属性（在Java中）也会暴露为字段。 该字段的可见性与 <code>lateinit</code> 属性的 setter 相同。</p><h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>在命名对象或伴生对象中声明的 Kotlin 属性会在该命名对象或包含伴生对象的类中具有静态幕后字段。</p><p>通常这些字段是私有的，但可以通过以下方式之一暴露出来：</p><ul><li><code>@JvmField</code> 注解；</li><li><code>lateinit</code> 修饰符；</li><li><code>const</code> 修饰符。</li></ul><p>使用 <code>@JvmField</code> 标注这样的属性使其成为与属性本身具有相同可见性的静态字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Key(val value: Int) &#123;</div><div class="line">    companion object &#123;</div><div class="line">        @JvmField</div><div class="line">        val COMPARATOR: Comparator&lt;Key&gt; = compareBy&lt;Key&gt; &#123; it.value &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">Key.COMPARATOR.compare(key1, key2);</div><div class="line">// Key 类中的 public static final 字段</div></pre></td></tr></table></figure><p>在命名对象或者伴生对象中的一个<a href="https://www.kotlincn.net/docs/reference/properties.html#延迟初始化属性" target="_blank" rel="external">延迟初始化的</a>属性具有与属性 setter 相同可见性的静态幕后字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object Singleton &#123;</div><div class="line">    lateinit var provider: Provider</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">Singleton.provider = new Provider();</div><div class="line">// 在 Singleton 类中的 public static 非-final 字段</div></pre></td></tr></table></figure><p>用 <code>const</code> 标注的（在类中以及在顶层的）属性在 Java 中会成为静态字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 文件 example.kt</div><div class="line"></div><div class="line">object Obj &#123;</div><div class="line">    const val CONST = 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C &#123;</div><div class="line">    companion object &#123;</div><div class="line">        const val VERSION = 9</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const val MAX = 239</div></pre></td></tr></table></figure><p>在 Java 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int c = Obj.CONST;</div><div class="line">int d = ExampleKt.MAX;</div><div class="line">int v = C.VERSION;</div></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>如上所述，Kotlin 将包级函数表示为静态方法。 Kotlin 还可以为命名对象或伴生对象中定义的函数生成静态方法，如果你将这些函数标注为 <code>@JvmStatic</code> 的话。 如果你使用该注解，编译器既会在相应对象的类中生成静态方法，也会在对象自身中生成实例方法。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    companion object &#123;</div><div class="line">        @JvmStatic fun foo() &#123;&#125;</div><div class="line">        fun bar() &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，<code>foo()</code> 在 Java 中是静态的，而 <code>bar()</code> 不是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C.foo(); // 没问题</div><div class="line">C.bar(); // 错误：不是一个静态方法</div><div class="line">C.Companion.foo(); // 保留实例方法</div><div class="line">C.Companion.bar(); // 唯一的工作方式</div></pre></td></tr></table></figure><p>对于命名对象也同样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">object Obj &#123;</div><div class="line">    @JvmStatic fun foo() &#123;&#125;</div><div class="line">    fun bar() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 Java 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Obj.foo(); // 没问题</div><div class="line">Obj.bar(); // 错误</div><div class="line">Obj.INSTANCE.bar(); // 没问题，通过单例实例调用</div><div class="line">Obj.INSTANCE.foo(); // 也没问题</div></pre></td></tr></table></figure><p><code>@JvmStatic</code>　注解也可以应用于对象或伴生对象的属性， 使其 getter 和 setter 方法在该对象或包含该伴生对象的类中是静态成员。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>Kotlin 的可见性以下列方式映射到 Java：</p><ul><li><code>private</code> 成员编译成 <code>private</code> 成员；</li><li><code>private</code> 的顶层声明编译成包级局部声明；</li><li><code>protected</code> 保持 <code>protected</code>（注意 Java 允许访问同一个包中其他类的受保护成员， 而 Kotlin 不能，所以 Java 类会访问更广泛的代码）；</li><li><code>internal</code> 声明会成为 Java 中的 <code>public</code>。<code>internal</code> 类的成员会通过名字修饰，使其更难以在 Java 中意外使用到，并且根据 Kotlin 规则使其允许重载相同签名的成员而互不可见；</li><li><code>public</code> 保持 <code>public</code>。</li></ul><h4 id="KClass"><a href="#KClass" class="headerlink" title="KClass"></a>KClass</h4><p>有时你需要调用有 <code>KClass</code> 类型参数的 Kotlin 方法。 因为没有从 <code>Class</code> 到 <code>KClass</code> 的自动转换，所以你必须通过调用 <code>Class&lt;T&gt;.kotlin</code> 扩展属性的等价形式来手动进行转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.class)</div></pre></td></tr></table></figure><h4 id="用-JvmName-解决签名冲突"><a href="#用-JvmName-解决签名冲突" class="headerlink" title="用 @JvmName 解决签名冲突"></a>用 @JvmName 解决签名冲突</h4><p>有时我们想让一个 Kotlin 中的命名函数在字节码中有另外一个 JVM 名称。 最突出的例子是由于<em>类型擦除</em>引发的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fun List&lt;String&gt;.filterValid(): List&lt;String&gt;</div><div class="line">fun List&lt;Int&gt;.filterValid(): List&lt;Int&gt;</div></pre></td></tr></table></figure><p>这两个函数不能同时定义，因为它们的 JVM 签名是一样的：<code>filterValid(Ljava/util/List;)Ljava/util/List;</code>。 如果我们真的希望它们在 Kotlin 中用相同名称，我们需要用 <code>@JvmName</code> 去标注其中的一个（或两个），并指定不同的名称作为参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun List&lt;String&gt;.filterValid(): List&lt;String&gt;</div><div class="line"></div><div class="line">@JvmName(&quot;filterValidInt&quot;)</div><div class="line">fun List&lt;Int&gt;.filterValid(): List&lt;Int&gt;</div></pre></td></tr></table></figure><p>在 Kotlin 中它们可以用相同的名称 <code>filterValid</code> 来访问，而在 Java 中，它们分别是 <code>filterValid</code> 和 <code>filterValidInt</code>。</p><p>同样的技巧也适用于属性 <code>x</code> 和函数 <code>getX()</code> 共存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val x: Int</div><div class="line">    @JvmName(&quot;getX_prop&quot;)</div><div class="line">    get() = 15</div><div class="line"></div><div class="line">fun getX() = 10</div></pre></td></tr></table></figure><h4 id="生成重载"><a href="#生成重载" class="headerlink" title="生成重载"></a>生成重载</h4><p>通常，如果你写一个有默认参数值的 Kotlin 函数，在 Java 中只会有一个所有参数都存在的完整参数签名的方法可见，如果希望向 Java 调用者暴露多个重载，可以使用 <code>@JvmOverloads</code> 注解。</p><p>该注解也适用于构造函数、静态方法等。它不能用于抽象方法，包括在接口中定义的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Foo @JvmOverloads constructor(x: Int, y: Double = 0.0) &#123;</div><div class="line">    @JvmOverloads fun f(a: String, b: Int = 0, c: String = &quot;abc&quot;) &#123;</div><div class="line">        ……</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于每一个有默认值的参数，都会生成一个额外的重载，这个重载会把这个参数和它右边的所有参数都移除掉。在上例中，会生成以下代码 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 构造函数：</div><div class="line">Foo(int x, double y)</div><div class="line">Foo(int x)</div><div class="line"></div><div class="line">// 方法</div><div class="line">void f(String a, int b, String c) &#123; &#125;</div><div class="line">void f(String a, int b) &#123; &#125;</div><div class="line">void f(String a) &#123; &#125;</div></pre></td></tr></table></figure><p>请注意，如<a href="https://www.kotlincn.net/docs/reference/classes.html#次构造函数" target="_blank" rel="external">次构造函数</a>中所述，如果一个类的所有构造函数参数都有默认值，那么会为其生成一个公有的无参构造函数。这就算没有 <code>@JvmOverloads</code> 注解也有效。</p><h4 id="受检异常-1"><a href="#受检异常-1" class="headerlink" title="受检异常"></a>受检异常</h4><p>如上所述，Kotlin 没有受检异常。 所以，通常 Kotlin 函数的 Java 签名不会声明抛出异常。 于是如果我们有一个这样的 Kotlin 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// example.kt</div><div class="line">package demo</div><div class="line"></div><div class="line">fun foo() &#123;</div><div class="line">    throw IOException()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后我们想要在 Java 中调用它并捕捉这个异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">try &#123;</div><div class="line">  demo.Example.foo();</div><div class="line">&#125;</div><div class="line">catch (IOException e) &#123; // 错误：foo() 未在 throws 列表中声明 IOException</div><div class="line">  // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为 <code>foo()</code> 没有声明 <code>IOException</code>，我们从 Java 编译器得到了一个报错消息。 为了解决这个问题，要在 Kotlin 中使用 <code>@Throws</code> 注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Throws(IOException::class)</div><div class="line">fun foo() &#123;</div><div class="line">    throw IOException()</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="空安全性"><a href="#空安全性" class="headerlink" title="空安全性"></a>空安全性</h4><p>当从 Java 中调用 Kotlin 函数时，没人阻止我们将 <em>null</em> 作为非空参数传递。 这就是为什么 Kotlin 给所有期望非空参数的公有函数生成运行时检测。 这样我们就能在 Java 代码里立即得到 <code>NullPointerException</code>。</p><h4 id="型变的泛型"><a href="#型变的泛型" class="headerlink" title="型变的泛型"></a>型变的泛型</h4><p>当 Kotlin 的类使用了<a href="https://www.kotlincn.net/docs/reference/generics.html#声明处型变" target="_blank" rel="external">声明处型变</a>，有两种选择可以从 Java 代码中看到它们的用法。让我们假设我们有以下类和两个使用它的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Box&lt;out T&gt;(val value: T)</div><div class="line"></div><div class="line">interface Base</div><div class="line">class Derived : Base</div><div class="line"></div><div class="line">fun boxDerived(value: Derived): Box&lt;Derived&gt; = Box(value)</div><div class="line">fun unboxBase(box: Box&lt;Base&gt;): Base = box.value</div></pre></td></tr></table></figure><p>一种看似理所当然地将这俩函数转换成 Java 代码的方式可能会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Box&lt;Derived&gt; boxDerived(Derived value) &#123; …… &#125;</div><div class="line">Base unboxBase(Box&lt;Base&gt; box) &#123; …… &#125;</div></pre></td></tr></table></figure><p>问题是，在 Kotlin 中我们可以这样写 <code>unboxBase(boxDerived(&quot;s&quot;))</code>，但是在 Java 中是行不通的，因为在 Java 中类 <code>Box</code> 在其泛型参数 <code>T</code> 上是<em>不型变的</em>，于是 <code>Box&lt;Derived&gt;</code> 并不是 <code>Box&lt;Base&gt;</code> 的子类。 要使其在 Java 中工作，我们按以下这样定义 <code>unboxBase</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Base unboxBase(Box&lt;? extends Base&gt; box) &#123; …… &#125;</div></pre></td></tr></table></figure><p>这里我们使用 Java 的<em>通配符类型</em>（<code>? extends Base</code>）来通过使用处型变来模拟声明处型变，因为在 Java 中只能这样。</p><p>当它<em>作为参数</em>出现时，为了让 Kotlin 的 API 在 Java 中工作，对于协变定义的 <code>Box</code> 我们生成 <code>Box&lt;Super&gt;</code> 作为 <code>Box&lt;? extends Super&gt;</code> （或者对于逆变定义的 <code>Foo</code> 生成 <code>Foo&lt;? super Bar&gt;</code>）。当它是一个返回值时， 我们不生成通配符，因为否则 Java 客户端将必须处理它们（并且它违反常用 Java 编码风格）。因此，我们的示例中的对应函数实际上翻译如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 作为返回类型——没有通配符</div><div class="line">Box&lt;Derived&gt; boxDerived(Derived value) &#123; …… &#125;</div><div class="line"> </div><div class="line">// 作为参数——有通配符</div><div class="line">Base unboxBase(Box&lt;? extends Base&gt; box) &#123; …… &#125;</div></pre></td></tr></table></figure><p>注意：当参数类型是 final 时，生成通配符通常没有意义，所以无论在什么地方 <code>Box&lt;String&gt;</code> 始终转换为 <code>Box&lt;String&gt;</code>。</p><p>如果我们在默认不生成通配符的地方需要通配符，我们可以使用 <code>@JvmWildcard</code> 注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun boxDerived(value: Derived): Box&lt;@JvmWildcard Derived&gt; = Box(value)</div><div class="line">// 将被转换成</div><div class="line">// Box&lt;? extends Derived&gt; boxDerived(Derived value) &#123; …… &#125;</div></pre></td></tr></table></figure><p>另一方面，如果我们根本不需要默认的通配符转换，我们可以使用<code>@JvmSuppressWildcards</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun unboxBase(box: Box&lt;@JvmSuppressWildcards Base&gt;): Base = box.value</div><div class="line">// 会翻译成</div><div class="line">// Base unboxBase(Box&lt;Base&gt; box) &#123; …… &#125;</div></pre></td></tr></table></figure><p>注意：<code>@JvmSuppressWildcards</code> 不仅可用于单个类型参数，还可用于整个声明（如函数或类），从而抑制其中的所有通配符。</p><h4 id="Nothing-类型翻译"><a href="#Nothing-类型翻译" class="headerlink" title="Nothing 类型翻译"></a>Nothing 类型翻译</h4><p>类型 <a href="https://www.kotlincn.net/docs/reference/exceptions.html#nothing-类型" target="_blank" rel="external"><code>Nothing</code></a> 是特殊的，因为它在 Java 中没有自然的对应。确实，每个 Java 引用类型，包括<code>java.lang.Void</code> 都可以接受 <code>null</code> 值，但是 Nothing 不行。因此，这种类型不能在 Java 世界中准确表示。这就是为什么在使用 <code>Nothing</code> 参数的地方 Kotlin 生成一个原始类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun emptyList(): List&lt;Nothing&gt; = listOf()</div><div class="line">// 会翻译成</div><div class="line">// List emptyList() &#123; …… &#125;</div></pre></td></tr></table></figure><h4 id="在-Kotlin-中使用-JNI"><a href="#在-Kotlin-中使用-JNI" class="headerlink" title="在 Kotlin 中使用 JNI"></a>在 Kotlin 中使用 JNI</h4><p>要声明一个在本地（C 或 C++）代码中实现的函数，你需要使用 <code>external</code> 修饰符来标记它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">external <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Double</span></div></pre></td></tr></table></figure><p>其余的过程与 Java 中的工作方式完全相同。</p><h2 id="Kotlin-高级编程"><a href="#Kotlin-高级编程" class="headerlink" title="Kotlin 高级编程"></a>Kotlin 高级编程</h2><h3 id="领域特定语言-DSL"><a href="#领域特定语言-DSL" class="headerlink" title="领域特定语言 DSL"></a>领域特定语言 DSL</h3><p>域特定语言（DSL）的基本思想是针对特定类型的问题的计算机语言，而不是面向任何类型的软件问题的通用语言。</p><h4 id="类型安全的构建器"><a href="#类型安全的构建器" class="headerlink" title="类型安全的构建器"></a>类型安全的构建器</h4><p><a href="http://www.groovy-lang.org/dsls.html#_nodebuilder" target="_blank" rel="external">构建器（builder）</a>的概念在 <em>Groovy</em> 社区中非常热门。 构建器允许以半声明（semi-declarative）的方式定义数据。构建器很适合用来<a href="http://www.groovy-lang.org/processing-xml.html#_creating_xml" target="_blank" rel="external">生成 XML</a>、 <a href="http://www.groovy-lang.org/swing.html" target="_blank" rel="external">布局 UI 组件</a>、 <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=296081" target="_blank" rel="external">描述 3D 场景</a>以及其他更多功能……</p><p>Kotlin 允许<em>检查类型</em>的构建器，比 Groovy 自身的动态类型实现更具吸引力。</p><p>HTML DSL kotlin 官方示例:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> result =</div><div class="line">            html &#123;</div><div class="line">                head &#123;</div><div class="line">                    title &#123; +<span class="string">"XML encoding with Kotlin"</span> &#125;</div><div class="line">                &#125;</div><div class="line">                body &#123;</div><div class="line">                    h1 &#123; +<span class="string">"XML encoding with Kotlin"</span> &#125;</div><div class="line">                    p &#123; +<span class="string">"this format can be used as an alternative markup to XML"</span> &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// an element with attributes and text content</span></div><div class="line">                    a(href = <span class="string">"http://jetbrains.com/kotlin"</span>) &#123; +<span class="string">"Kotlin"</span> &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// mixed content</span></div><div class="line">                    p &#123;</div><div class="line">                        +<span class="string">"This is some"</span></div><div class="line">                        b &#123; +<span class="string">"mixed"</span> &#125;</div><div class="line">                        +<span class="string">"text. For more see the"</span></div><div class="line">                        a(href = <span class="string">"http://jetbrains.com/kotlin"</span>) &#123; +<span class="string">"Kotlin"</span> &#125;</div><div class="line">                        +<span class="string">"project"</span></div><div class="line">                    &#125;</div><div class="line">                    p &#123; +<span class="string">"some text"</span> &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// content generated from command-line arguments</span></div><div class="line">                    p &#123;</div><div class="line">                        +<span class="string">"Command line arguments were:"</span></div><div class="line">                        ul &#123;</div><div class="line">                            <span class="keyword">for</span> (arg <span class="keyword">in</span> args)</div><div class="line">                                li &#123; +arg &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">    println(result)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">render</span><span class="params">(builder: <span class="type">StringBuilder</span>, indent: <span class="type">String</span>)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextElement</span></span>(<span class="keyword">val</span> text: String) : Element &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">render</span><span class="params">(builder: <span class="type">StringBuilder</span>, indent: <span class="type">String</span>)</span></span> &#123;</div><div class="line">        builder.append(<span class="string">"<span class="subst">$indent</span><span class="subst">$text</span>\n"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@DslMarker</span></div><div class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlTagMarker</span></span></div><div class="line"></div><div class="line"><span class="meta">@HtmlTagMarker</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tag</span></span>(<span class="keyword">val</span> name: String) : Element &#123;</div><div class="line">    <span class="keyword">val</span> children = arrayListOf&lt;Element&gt;()</div><div class="line">    <span class="keyword">val</span> attributes = hashMapOf&lt;String, String&gt;()</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Element&gt;</span> <span class="title">initTag</span><span class="params">(tag: <span class="type">T</span>, init: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123;</div><div class="line">        tag.init()</div><div class="line">        children.add(tag)</div><div class="line">        <span class="keyword">return</span> tag</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">render</span><span class="params">(builder: <span class="type">StringBuilder</span>, indent: <span class="type">String</span>)</span></span> &#123;</div><div class="line">        builder.append(<span class="string">"<span class="subst">$indent</span>&lt;<span class="subst">$name</span><span class="subst">$&#123;renderAttributes()&#125;</span>&gt;\n"</span>)</div><div class="line">        <span class="keyword">for</span> (c <span class="keyword">in</span> children) &#123;</div><div class="line">            c.render(builder, indent + <span class="string">"  "</span>)</div><div class="line">        &#125;</div><div class="line">        builder.append(<span class="string">"<span class="subst">$indent</span>&lt;/<span class="subst">$name</span>&gt;\n"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">renderAttributes</span><span class="params">()</span></span>: String? &#123;</div><div class="line">        <span class="keyword">val</span> builder = StringBuilder()</div><div class="line">        <span class="keyword">for</span> (a <span class="keyword">in</span> attributes.keys) &#123;</div><div class="line">            builder.append(<span class="string">" <span class="subst">$a</span>=\"<span class="subst">$&#123;attributes[a]&#125;</span>\""</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> builder.toString()</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</div><div class="line">        <span class="keyword">val</span> builder = StringBuilder()</div><div class="line">        render(builder, <span class="string">""</span>)</div><div class="line">        <span class="keyword">return</span> builder.toString()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TagWithText</span></span>(name: String) : Tag(name) &#123;</div><div class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">unaryPlus</span><span class="params">()</span></span> &#123;</div><div class="line">        children.add(TextElement(<span class="keyword">this</span>))</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTML</span></span>() : TagWithText(<span class="string">"html"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">head</span><span class="params">(init: <span class="type">Head</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = initTag(Head(), init)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">body</span><span class="params">(init: <span class="type">Body</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = initTag(Body(), init)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>() : TagWithText(<span class="string">"head"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">title</span><span class="params">(init: <span class="type">Title</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = initTag(Title(), init)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span></span>() : TagWithText(<span class="string">"title"</span>)</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BodyTag</span></span>(name: String) : TagWithText(name) &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">(init: <span class="type">B</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = initTag(B(), init)</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">p</span><span class="params">(init: <span class="type">P</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = initTag(P(), init)</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">h1</span><span class="params">(init: <span class="type">H1</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = initTag(H1(), init)</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ul</span><span class="params">(init: <span class="type">UL</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = initTag(UL(), init)</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">(href: <span class="type">String</span>, init: <span class="type">A</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        <span class="keyword">val</span> a = initTag(A(), init)</div><div class="line">        a.href = href</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span></span>() : BodyTag(<span class="string">"body"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UL</span></span>() : BodyTag(<span class="string">"ul"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">li</span><span class="params">(init: <span class="type">LI</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) = initTag(LI(), init)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>() : BodyTag(<span class="string">"b"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LI</span></span>() : BodyTag(<span class="string">"li"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span></span>() : BodyTag(<span class="string">"p"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">H1</span></span>() : BodyTag(<span class="string">"h1"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>() : BodyTag(<span class="string">"a"</span>) &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> href: String</div><div class="line">        <span class="keyword">get</span>() = attributes[<span class="string">"href"</span>]!!</div><div class="line">        <span class="keyword">set</span>(value) &#123;</div><div class="line">            attributes[<span class="string">"href"</span>] = value</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">html</span><span class="params">(init: <span class="type">HTML</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): HTML &#123;</div><div class="line">    <span class="keyword">val</span> html = HTML()</div><div class="line">    html.init()</div><div class="line">    <span class="keyword">return</span> html</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面实现 HTML 标签,实际上是调用一个 lambda函数，用一个标签接收者的函数类型zuo作为参数,使在函数内部调用该实例的成员。</p><h4 id="几个厉害的-DSL-项目"><a href="#几个厉害的-DSL-项目" class="headerlink" title="几个厉害的 DSL 项目"></a>几个厉害的 DSL 项目</h4><ul><li><a href="https://github.com/Kotlin/anko" target="_blank" rel="external">Anko</a> 用于 Android 的，用于描述 UI 。</li><li><a href="https://github.com/cqjjjzr/Gensokyo" target="_blank" rel="external">Gensokyo</a> 用于  Swing  的，用于描述 UI </li><li><a href="https://github.com/kotlintest/kotlintest" target="_blank" rel="external">KotlinTest</a> Kotlin测试框架基于优秀的Scalatest</li></ul><h3 id="协程-Coroutine"><a href="#协程-Coroutine" class="headerlink" title="协程 Coroutine"></a>协程 Coroutine</h3><p>在 Kotlin 1.1 中协程是实验性的。另外kotlin 为了减少程序体积,根据需要使用协程,你要加入<code>kotlinx-coroutines-core</code> 库.</p><p>一些 API 启动长时间运行的操作（例如网络 IO、文件 IO、CPU 或 GPU 密集型任务等），并要求调用者阻塞直到它们完成。协程提供了一种避免阻塞线程并用更廉价、更可控的操作替代线程阻塞的方法：协程<em>挂起</em>。</p><p>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中<em>顺序</em>地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器！）上调度执行，而代码则保持如同顺序执行一样简单。</p><p>许多在其他语言中可用的异步机制可以使用 Kotlin 协程实现为库。这包括源于 C# 和 ECMAScript 的 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions" target="_blank" rel="external"><code>async</code>/<code>await</code></a>、源于 Go 的 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#channels" target="_blank" rel="external">管道</a> 和 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#select-expression" target="_blank" rel="external"><code>select</code></a> 以及源于 C# 和 Python <a href="https://www.kotlincn.net/docs/reference/coroutines.html#kotlincoroutines-中的生成器-api" target="_blank" rel="external">生成器/<code>yield</code></a>。关于提供这些结构的库请参见其<a href="https://www.kotlincn.net/docs/reference/coroutines.html#标准-api" target="_blank" rel="external">下文</a>描述。</p><h4 id="阻塞-vs-挂起"><a href="#阻塞-vs-挂起" class="headerlink" title="阻塞 vs 挂起"></a>阻塞 vs 挂起</h4><p>基本上，协程计算可以<em>被挂起</em>而无需<em>阻塞线程</em>。线程阻塞的代价通常是昂贵的，尤其在高负载时，因为只有相对少量线程实际可用，因此阻塞其中一个会导致一些重要的任务被延迟。</p><p>另一方面，协程挂起几乎是无代价的。不需要上下文切换或者 OS 的任何其他干预。最重要的是，挂起可以在很大程度上由用户库控制：作为库的作者，我们可以决定挂起时发生什么并根据需求优化/记日志/截获。</p><p>另一个区别是，协程不能在随机的指令中挂起，而只能在所谓的<em>挂起点</em>挂起，这会调用特别标记的函数。</p><h4 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h4><p>当我们调用标记有特殊修饰符 <code>suspend</code> 的函数时，会发生挂起：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(foo: <span class="type">Foo</span>)</span></span>: Bar &#123;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样的函数称为<em>挂起函数</em>，因为调用它们可能挂起协程（如果相关调用的结果已经可用，库可以决定继续进行而不挂起）。挂起函数能够以与普通函数相同的方式获取参数和返回值，但它们只能从协程和其他挂起函数中调用。事实上，要启动协程，必须至少有一个挂起函数，它通常是匿名的（即它是一个挂起 lambda 表达式）。让我们来看一个例子，一个简化的 <code>async()</code> 函数（源自 <a href="https://www.kotlincn.net/docs/reference/coroutines.html#kotlincoroutines-中的生成器-api" target="_blank" rel="external"><code>kotlinx.coroutines</code></a> 库）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">async</span><span class="params">(block: <span class="type">suspend</span> ()</span></span> -&gt; T)</div></pre></td></tr></table></figure><p>这里的 <code>async()</code> 是一个普通函数（不是挂起函数），但是它的 <code>block</code> 参数具有一个带 <code>suspend</code> 修饰符的函数类型： <code>suspend () -&gt; T</code>。所以，当我们将一个 lambda 表达式传给 <code>async()</code> 时，它会是<em>挂起 lambda 表达式</em>，于是我们可以从中调用挂起函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">async &#123;</div><div class="line">    doSomething(foo)</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>继续该类比，<code>await()</code> 可以是一个挂起函数（因此也可以在一个 <code>async {}</code> 块中调用），该函数挂起一个协程，直到一些计算完成并返回其结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">async &#123;</div><div class="line">    ……</div><div class="line">    <span class="keyword">val</span> result = computation.await()</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>更多关于 <code>async/await</code> 函数实际在 <code>kotlinx.coroutines</code> 中如何工作的信息可以在<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions" target="_blank" rel="external">这里</a>找到。</p><p>请注意，挂起函数 <code>await()</code> 和 <code>doSomething()</code> 不能在像 <code>main()</code> 这样的普通函数中调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    doSomething() <span class="comment">// 错误：挂起函数从非协程上下文调用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还要注意的是，挂起函数可以是虚拟的，当覆盖它们时，必须指定 <code>suspend</code> 修饰符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</div><div class="line">    suspend <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>: <span class="type">Base &#123;</span></span></div><div class="line">    <span class="keyword">override</span> suspend <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; …… &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="RestrictsSuspension-注解"><a href="#RestrictsSuspension-注解" class="headerlink" title="@RestrictsSuspension 注解"></a>@RestrictsSuspension 注解</h4><p>扩展函数（和 lambda 表达式）也可以标记为 <code>suspend</code>，就像普通的一样。这允许创建 <a href="https://www.kotlincn.net/docs/reference/type-safe-builders.html" target="_blank" rel="external">DSL</a> 及其他用户可扩展的 API。在某些情况下，库作者需要阻止用户添加<em>新方式</em>来挂起协程。</p><p>为了实现这一点，可以使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-restricts-suspension/index.html" target="_blank" rel="external"><code>@RestrictsSuspension</code></a> 注解。当接收者类/接口 <code>R</code> 用它标注时，所有挂起扩展都需要委托给 <code>R</code> 的成员或其它委托给它的扩展。由于扩展不能无限相互委托（程序不会终止），这保证所有挂起都通过调用 <code>R</code> 的成员发生，库的作者就可以完全控制了。</p><p>这在<em>少数</em>情况是需要的，当每次挂起在库中以特殊方式处理时。例如，当通过 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-sequence.html" target="_blank" rel="external"><code>buildSequence()</code></a> 函数实现<a href="https://www.kotlincn.net/docs/reference/coroutines.html#kotlincoroutines-中的生成器-api" target="_blank" rel="external">下文</a>所述的生成器时，我们需要确保在协程中的任何挂起调用最终调用 <code>yield()</code> 或 <code>yieldAll()</code> 而不是任何其他函数。这就是为什么 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-sequence-builder/index.html" target="_blank" rel="external"><code>SequenceBuilder</code></a> 用 <code>@RestrictsSuspension</code> 注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestrictsSuspension</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceBuilder</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参见其 <a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/experimental/SequenceBuilder.kt" target="_blank" rel="external">Github 上</a> 的源代码。</p><h4 id="协程的内部机制"><a href="#协程的内部机制" class="headerlink" title="协程的内部机制"></a>协程的内部机制</h4><p>我们不是在这里给出一个关于协程如何工作的完整解释，然而粗略地认识发生了什么是相当重要的。</p><p>协程完全通过编译技术实现（不需要来自 VM 或 OS 端的支持），挂起通过代码来生效。基本上，每个挂起函数（优化可能适用，但我们不在这里讨论）都转换为状态机，其中的状态对应于挂起调用。刚好在挂起前，下一状态与相关局部变量等一起存储在编译器生成的类的字段中。在恢复该协程时，恢复局部变量并且状态机从刚好挂起之后的状态进行。</p><p>挂起的协程可以作为保持其挂起状态与局部变量的对象来存储和传递。这种对象的类型是 <code>Continuation</code>，而这里描述的整个代码转换对应于经典的<a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="_blank" rel="external">延续性传递风格（Continuation-passing style）</a>。因此，挂起函数有一个 <code>Continuation</code> 类型的额外参数作为高级选项。</p><p>关于协程工作原理的更多细节可以在<a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md" target="_blank" rel="external">这个设计文档</a>中找到。在其他语言（如 C# 或者 ECMAScript 2016）中的 async/await 的类似描述与此相关，虽然它们实现的语言功能可能不像 Kotlin 协程这样通用。</p><h4 id="协程的实验性状态"><a href="#协程的实验性状态" class="headerlink" title="协程的实验性状态"></a>协程的实验性状态</h4><p>协程的设计是<a href="https://www.kotlincn.net/docs/reference/compatibility.html#实验性的功能" target="_blank" rel="external">实验性的</a>，这意味着它可能在即将发布的版本中更改。当在 Kotlin 1.1 中编译协程时，默认情况下会报一个警告：<em>“协程”功能是实验性的</em>。要移出该警告，你需要指定 <a href="https://www.kotlincn.net/docs/diagnostics/experimental-coroutines.html" target="_blank" rel="external">opt-in 标志</a>。</p><p>由于其实验性状态，标准库中协程相关的 API 放在 <code>kotlin.coroutines.experimental</code> 包下。当设计完成并且实验性状态解除时，最终的 API 会移动到 <code>kotlin.coroutines</code>，并且实验包会被保留（可能在一个单独的构件中）以实现向后兼容。</p><p><strong>重要注意事项</strong>：我们建议库作者遵循相同惯例：给暴露基于协程 API 的包添加“experimental”后缀（如 <code>com.example.experimental</code>），以使你的库保持二进制兼容。当最终 API 发布时，请按照下列步骤操作：</p><ul><li>将所有 API 复制到 <code>com.example</code>（没有 experimental 后缀），</li><li>保持实验包的向后兼容性。</li></ul><p>这将最小化你的用户的迁移问题。</p><h4 id="标准-API"><a href="#标准-API" class="headerlink" title="标准 API"></a>标准 API</h4><p>协程有三个主要组成部分：</p><ul><li>语言支持（即如上所述的挂起功能），</li><li>Kotlin 标准库中的底层核心 API，</li><li>可以直接在用户代码中使用的高级 API。</li></ul><h4 id="底层-API：kotlin-coroutines"><a href="#底层-API：kotlin-coroutines" class="headerlink" title="底层 API：kotlin.coroutines"></a>底层 API：kotlin.coroutines</h4><p>底层 API 相对较小，并且除了创建更高级的库之外，不应该使用它。 它由两个主要包组成：</p><ul><li><code>kotlin.coroutines.experimental</code>带有主要类型与下述原语<ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/create-coroutine.html" target="_blank" rel="external"><code>createCoroutine()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/start-coroutine.html" target="_blank" rel="external"><code>startCoroutine()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/suspend-coroutine.html" target="_blank" rel="external"><code>suspendCoroutine()</code></a></li></ul></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental.intrinsics/index.html" target="_blank" rel="external"><code>kotlin.coroutines.experimental.intrinsics</code></a> 带有甚至更底层的内在函数如 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental.intrinsics/suspend-coroutine-or-return.html" target="_blank" rel="external"><code>suspendCoroutineOrReturn</code></a></li></ul><p>关于这些 API 用法的更多细节可以在<a href="https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md" target="_blank" rel="external">这里</a>找到。</p><h4 id="kotlin-coroutines-中的生成器-API"><a href="#kotlin-coroutines-中的生成器-API" class="headerlink" title="kotlin.coroutines 中的生成器 API"></a>kotlin.coroutines 中的生成器 API</h4><p><code>kotlin.coroutines.experimental</code> 中仅有的“应用程序级”函数是</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-sequence.html" target="_blank" rel="external"><code>buildSequence()</code></a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-iterator.html" target="_blank" rel="external"><code>buildIterator()</code></a></li></ul><p>这些包含在 <code>kotlin-stdlib</code> 中因为他们与序列相关。这些函数（我们可以仅限于这里的 <code>buildSequence()</code>）实现了 <em>生成器</em> ，即提供一种廉价构建惰性序列的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> fibonacciSeq = buildSequence &#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> b = <span class="number">1</span></div><div class="line"></div><div class="line">    yield(<span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        yield(a + b)</div><div class="line"></div><div class="line">        <span class="keyword">val</span> tmp = a + b</div><div class="line">        a = b</div><div class="line">        b = tmp</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这通过创建一个协程生成一个惰性的、潜在无限的斐波那契数列，该协程通过调用 <code>yield()</code> 函数来产生连续的斐波纳契数。当在这样的序列的迭代器上迭代每一步，都会执行生成下一个数的协程的另一部分。因此，我们可以从该序列中取出任何有限的数字列表，例如 <code>fibonacciSeq.take(8).toList()</code> 结果是 <code>[1, 1, 2, 3, 5, 8, 13, 21]</code>。协程足够廉价使这很实用。</p><p>为了演示这样一个序列的真正惰性，让我们在调用 <code>buildSequence()</code> 内部输出一些调试信息：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> lazySeq = buildSequence &#123;</div><div class="line">    print(<span class="string">"START "</span>)</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</div><div class="line">        yield(i)</div><div class="line">        print(<span class="string">"STEP "</span>)</div><div class="line">    &#125;</div><div class="line">    print(<span class="string">"END"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出序列的前三个元素</span></div><div class="line">lazySeq.take(<span class="number">3</span>).forEach &#123; print(<span class="string">"<span class="subst">$it</span> "</span>) &#125;</div></pre></td></tr></table></figure><p>运行上面的代码看，是不是我们输出前三个元素的数字与生成循环的 <code>STEP</code> 有交叉。这意味着计算确实是惰性的。要输出 <code>1</code>，我们只执行到第一个 <code>yield(i)</code>，并且过程中会输出 <code>START</code>。然后，输出 <code>2</code>，我们需要继续下一个 <code>yield(i)</code>，并会输出 <code>STEP</code>。<code>3</code> 也一样。永远不会输出再下一个 <code>STEP</code>（以及<code>END</code>），因为我们再也没有请求序列的后续元素。</p><p>为了一次产生值的集合（或序列），可以使用 <code>yieldAll()</code> 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> lazySeq = buildSequence &#123;</div><div class="line">    yield(<span class="number">0</span>)</div><div class="line">    yieldAll(<span class="number">1.</span><span class="number">.10</span>) </div><div class="line">&#125;</div><div class="line"></div><div class="line">lazySeq.forEach &#123; print(<span class="string">"<span class="subst">$it</span> "</span>) &#125;</div></pre></td></tr></table></figure><p><code>buildIterator()</code> 的工作方式类似于 <code>buildSequence()</code>，但返回一个惰性迭代器。</p><p>可以通过为 <code>SequenceBuilder</code> 类写挂起扩展（带有<a href="https://www.kotlincn.net/docs/reference/coroutines.html#restrictssuspension-注解" target="_blank" rel="external">上文</a>描述的 <code>@RestrictsSuspension</code> 注解）来为 <code>buildSequence()</code> 添加自定义生产逻辑（custom yielding logic）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">suspend <span class="function"><span class="keyword">fun</span> SequenceBuilder<span class="type">&lt;Int&gt;</span>.<span class="title">yieldIfOdd</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span>) yield(x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> lazySeq = buildSequence &#123;</div><div class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) yieldIfOdd(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="其他高级-API：kotlinx-coroutines"><a href="#其他高级-API：kotlinx-coroutines" class="headerlink" title="其他高级 API：kotlinx.coroutines"></a>其他高级 API：kotlinx.coroutines</h4><p>只有与协程相关的核心 API 可以从 Kotlin 标准库获得。这主要包括所有基于协程的库可能使用的核心原语和接口。</p><p>大多数基于协程的应用程序级API都作为单独的库发布：<a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="external"><code>kotlinx.coroutines</code></a>。这个库覆盖了</p><ul><li>使用<code>kotlinx-coroutines-core</code>的平台无关异步编程</li></ul><ul><li>此模块包括支持 <code>select</code> 和其他便利原语的类似 Go 的管道</li><li>这个库的综合指南<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md" target="_blank" rel="external">在这里</a>。</li></ul><ul><li><p>基于 JDK 8 中的 <code>CompletableFuture</code> 的 API：<code>kotlinx-coroutines-jdk8</code></p></li><li><p>基于 JDK 7 及更高版本 API 的非阻塞 IO（NIO）：<code>kotlinx-coroutines-nio</code></p></li><li><p>支持 Swing (<code>kotlinx-coroutines-swing</code>) 和 JavaFx (<code>kotlinx-coroutines-javafx</code>)</p></li><li><p>支持 RxJava：<code>kotlinx-coroutines-rx</code></p></li></ul><p>这些库既作为使通用任务易用的便利的 API，也作为如何构建基于协程的库的端到端示例。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>与大多数语言不同，Kotlin 区分可变集合和不可变集合（lists、sets、maps 等）。精确控制什么时候集合可编辑有助于消除 bug 和设计良好的 API。</p><p>预先了解一个可变集合的只读 <em>视图</em> 和一个真正的不可变集合之间的区别是很重要的。它们都容易创建，但类型系统不能表达它们的差别，所以由你来跟踪（是否相关）。</p><p>Kotlin 的 <code>List&lt;out T&gt;</code> 类型是一个提供只读操作如 <code>size</code>、<code>get</code>等的接口。和 Java 类似，它继承自 <code>Collection&lt;T&gt;</code> 进而继承自 <code>Iterable&lt;T&gt;</code>。改变 list 的方法是由 <code>MutableList&lt;T&gt;</code> 加入的。这一模式同样适用于 <code>Set&lt;out T&gt;/MutableSet&lt;T&gt;</code> 及 <code>Map&lt;K, out V&gt;/MutableMap&lt;K, V&gt;</code>。</p><p>我们可以看下 list 及 set 类型的基本用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numbers: MutableList&lt;<span class="built_in">Int</span>&gt; = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> readOnlyView: List&lt;<span class="built_in">Int</span>&gt; = numbers</div><div class="line">println(numbers)        <span class="comment">// 输出 "[1, 2, 3]"</span></div><div class="line">numbers.add(<span class="number">4</span>)</div><div class="line">println(readOnlyView)   <span class="comment">// 输出 "[1, 2, 3, 4]"</span></div><div class="line">readOnlyView.clear()    <span class="comment">// -&gt; 不能编译</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> strings = hashSetOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"c"</span>)</div><div class="line">assert(strings.size == <span class="number">3</span>)</div></pre></td></tr></table></figure><p>Kotlin 没有专门的语法结构创建 list 或 set。 要用标准库的方法，如 <code>listOf()</code>、 <code>mutableListOf()</code>、 <code>setOf()</code>、 <code>mutableSetOf()</code>。 在非性能关键代码中创建 map 可以用一个简单的<a href="https://www.kotlincn.net/docs/reference/idioms.html#只读-map" target="_blank" rel="external">惯用法</a>来完成：<code>mapOf(a to b, c to d)</code>。</p><p>注意上面的 <code>readOnlyView</code> 变量（译者注：与对应可变集合变量 <code>numbers</code>）指向相同的底层 list 并会随之改变。 如果一个 list 只存在只读引用，我们可以考虑该集合完全不可变。创建一个这样的集合的一个简单方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> items = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure><p>目前 <code>listOf</code> 方法是使用 array list 实现的，但是未来可以利用它们知道自己不能变的事实，返回更节约内存的完全不可变的集合类型。</p><p>注意这些类型是<a href="#型变">协变的</a>。这意味着，你可以把一个 <code>List&lt;Rectangle&gt;</code> 赋值给 <code>List&lt;Shape&gt;</code> 假定 Rectangle 继承自 Shape。对于可变集合类型这是不允许的，因为这将导致运行时故障。</p><p>有时你想给调用者返回一个集合在某个特定时间的一个快照, 一个保证不会变的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _items = mutableListOf&lt;String&gt;()</div><div class="line">    <span class="keyword">val</span> items: List&lt;String&gt; <span class="keyword">get</span>() = _items.toList()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个 <code>toList</code> 扩展方法只是复制列表项，因此返回的 list 保证永远不会改变。</p><p>List 和 set 有很多有用的扩展方法值得熟悉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> items = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">items.first() == <span class="number">1</span></div><div class="line">items.last() == <span class="number">4</span></div><div class="line">items.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;   <span class="comment">// 返回 [2, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> rwList = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">rwList.requireNoNulls()        <span class="comment">// 返回 [1, 2, 3]</span></div><div class="line"><span class="keyword">if</span> (rwList.none &#123; it &gt; <span class="number">6</span> &#125;) println(<span class="string">"No items above 6"</span>)  <span class="comment">// 输出“No items above 6”</span></div><div class="line"><span class="keyword">val</span> item = rwList.firstOrNull()</div></pre></td></tr></table></figure><p>…… 以及所有你所期望的实用工具，例如 sort、zip、fold、reduce 等等。</p><p>Map 遵循同样模式。它们可以容易地实例化和访问，像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> readWriteMap = hashMapOf(<span class="string">"foo"</span> to <span class="number">1</span>, <span class="string">"bar"</span> to <span class="number">2</span>)</div><div class="line">println(readWriteMap[<span class="string">"foo"</span>])  <span class="comment">// 输出“1”</span></div><div class="line"><span class="keyword">val</span> snapshot: Map&lt;String, <span class="built_in">Int</span>&gt; = HashMap(readWriteMap)</div></pre></td></tr></table></figure><h3 id="类型安全和智能转换"><a href="#类型安全和智能转换" class="headerlink" title="类型安全和智能转换"></a>类型安全和智能转换</h3><h4 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h4><p>Kotlin 的类型系统</p><ul><li>可空类型</li><li>非空类型</li></ul><p>它消除了很多编程语言（如: Java）来自于代码空引用,而导致的 <code>NullPointerException</code> 或简称 <code>NPE</code> 。</p><p>NOTE: Kotlin 发生 NPE 原因可能如下:</p><ul><li>显式调用 <code>throw NullPointerException()</code></li><li>使用了下文描述的 <code>!!</code> 操作符 </li><li>外部 Java 代码导致的</li></ul><p>在上面 <a href="#变量">变量</a>  中, Kotlin 默认声明变量时是非空类型的,要使该变量接收 <code>null</code> 值，需使用 <code>？</code> 操作符 , 例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var aNullNothing = null</div><div class="line">var bNullUnable: Int = null //不能为空</div><div class="line">var cNullUnable = 1 //不能为空</div><div class="line">var cNullable: Int? = null //能为空</div><div class="line">var dNullable: Any? = 1 //能为空 </div><div class="line"></div><div class="line">fun fun0(): Unit &#123;</div><div class="line">    aNullNothing = 1 //Nothing error</div><div class="line">    cNullUnable = null</div><div class="line">    cNullable = 1</div><div class="line">    dNullable = null //可以 null</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当声明可空类型变量时,它是不安全的,访问方法或属性时需要作处理:</p><ul><li>在条件中检查 null ,但仅适用于 <code>val</code> 且不可覆盖（即不能用 open 修饰）或者 <code>get</code> 的不可变的变量。</li><li>安全的调用 <code>?.</code> , 若为null 则跳过,否则接着调用</li><li>!! 操作符 ,会返回一个非空的值,否则抛出一个 <code>NPE</code> 异常 </li></ul><p>条件中检查 nul 例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">open class TestCheckNull &#123;</div><div class="line">    val cReadNullable: Int? = 1</div><div class="line">    val cGetReadNullable: Int? get() = 1</div><div class="line">    open val cOverrideReadNullable: Int? = 1</div><div class="line"></div><div class="line">    fun fun0(): Unit &#123;</div><div class="line">        if (cReadNullable != null) &#123;</div><div class="line">            cReadNullable.dec() //tips replace safe access expression</div><div class="line">        &#125;</div><div class="line">        if (cGetReadNullable != null) &#123;</div><div class="line">            cGetReadNullable.dec()</div><div class="line">        &#125;</div><div class="line">        if (cOverrideReadNullable != null) &#123;</div><div class="line">            cOverrideReadNullable.dec()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>安全调用和!! 操作符对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cNullUnable.dec() //保证不会导致 NPE</div><div class="line">val hc = dNullable?.hashCode() //dNullable == null return null, hc is null</div><div class="line">val dec = cNullable?.dec() // cNullable !=null return cNullable.dec(),dec is &quot;0&quot;</div><div class="line">cNullable!!.dec() // cNullable !=null execute dec()</div><div class="line">dNullable!!.toString() // dNullable == null throws NPE</div><div class="line">var aNotNullObject = cNullable!!</div></pre></td></tr></table></figure><h4 id="类型检测和安全的类型转换"><a href="#类型检测和安全的类型转换" class="headerlink" title="类型检测和安全的类型转换"></a>类型检测和安全的类型转换</h4><ul><li><code>is</code> <code>!is</code> 运算符检测一个表达式是否某类型的一个实例。在许多情况下，不需要在 Kotlin 中使用显式转换操作符，因为编译器跟踪不可变值的 <code>is</code>-检查，并在需要时自动插入（<strong>安全</strong>的）转换:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">val obj: Any = &quot;&quot;</div><div class="line">if (obj is String) &#123;</div><div class="line">    print(obj.length)</div><div class="line">&#125;</div><div class="line">if (obj !is String) &#123; // 与 !(obj is String) 相同</div><div class="line">    print(&quot;Not a String&quot;)</div><div class="line">&#125; else if (obj is String) &#123;</div><div class="line">    print(obj.length)</div><div class="line">&#125; else &#123;</div><div class="line">    print(obj.length)</div><div class="line">&#125;</div><div class="line">when(obj)&#123;</div><div class="line">    is String -&gt; obj.length</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>as</code> <code>as?</code> 运算符能把对象转换为目标类型，常规类型转换可能会导致 <code>ClassCastException</code>。使用安全的类型转换符 <code>as?</code>，如果尝试转换不成功则返回 <em>null</em>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">val father = Father()</div><div class="line">val son = Son()</div><div class="line">println(father is Son)</div><div class="line">println(son is Father)</div><div class="line"></div><div class="line">val fatherSon: Father = Son()</div><div class="line">println(fatherSon is Son)</div><div class="line">println(fatherSon is Father)</div><div class="line"></div><div class="line">val sonFatherSon: Son = fatherSon as Son</div><div class="line">println(sonFatherSon != null)</div><div class="line"></div><div class="line">val newFather: Son? = father as? Son</div><div class="line">val newFather1 = father as? Son  //newFather1 start define val newFather : Son?</div><div class="line">val newFather2 = father as Son // newFather1 start define val newFather : Son</div><div class="line">println(newFather == null)</div></pre></td></tr></table></figure><p>NOTE: Kotlin 类型检测十分智能, 想了解请更多参考 <a href="https://kotlinlang.org/docs/reference/typecasts.html#type-checks-and-casts-is-and-as" target="_blank" rel="external">Type Checks and Casts</a></p><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>Kotlin 允许我们为自己的类型提供预定义的一组操作符的实现。这些操作符具有固定的符号表示（如 <code>+</code> 或 <code>*</code>）和固定的<a href="https://www.kotlincn.net/docs/reference/grammar.html#precedence" target="_blank" rel="external">优先级</a>。为实现这样的操作符，我们为相应的类型（即二元操作符左侧的类型和一元操作符的参数类型）提供了一个固定名字的<a href="l#成员函数">成员函数</a>或<a href="#扩展函数">扩展函数</a>。<br>重载操作符的函数需要用 <code>operator</code> 修饰符标记。</p><p>另外，我们描述为不同操作符规范操作符重载的约定。</p><h4 id="一元前缀操作符"><a href="#一元前缀操作符" class="headerlink" title="一元前缀操作符"></a>一元前缀操作符</h4><table><thead><tr><th>表达式</th><th>翻译为</th></tr></thead><tbody><tr><td>+a</td><td>a.unaryPlus()</td></tr><tr><td>-a</td><td>a.unaryMinus()</td></tr><tr><td>!a</td><td>a.not()</td></tr></tbody></table><p>这个表是说，当编译器处理例如表达式 <code>+a</code> 时，它执行以下步骤：</p><ul><li>确定 <code>a</code> 的类型，令其为 <code>T</code>。</li><li>为接收者 <code>T</code> 查找一个带有 <code>operator</code> 修饰符的无参函数 <code>unaryPlus（）</code>，即成员函数或扩展函数。</li><li>如果函数不存在或不明确，则导致编译错误。</li><li>如果函数存在且其返回类型为 <code>R</code>，那就表达式 <code>+a</code> 具有类型 <code>R</code>。</li></ul><p><em>注意</em> 这些操作以及所有其他操作都针对<a href="#基本数据类型">基本类型</a>做了优化，不会为它们引入函数调用的开销。</p><p>以下是如何重载一元减运算符的示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</div><div class="line"></div><div class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span> = Point(-x, -y)</div><div class="line"></div><div class="line"><span class="keyword">val</span> point = Point(<span class="number">10</span>, <span class="number">20</span>)</div><div class="line">println(-point)  <span class="comment">// 输出“(-10, -20)”</span></div></pre></td></tr></table></figure><h4 id="递增与递减"><a href="#递增与递减" class="headerlink" title="递增与递减"></a>递增与递减</h4><table><thead><tr><th>表达式</th><th>翻译为</th></tr></thead><tbody><tr><td>a++</td><td>a.inc() + 见下文</td></tr><tr><td>a–</td><td>a.dec() + 见下文</td></tr></tbody></table><p><code>inc()</code> 和 <code>dec()</code> 函数必须返回一个值，它用于赋值给使用<code>++</code> 或 <code>--</code> 操作的变量。它们不应该改变在其上调用 <code>inc()</code> 或 <code>dec()</code> 的对象。</p><p>编译器执行以下步骤来解析<em>后缀</em>形式的操作符，例如 <code>a++</code>：</p><ul><li>确定 <code>a</code> 的类型，令其为 <code>T</code>。</li><li>查找一个适用于类型为 <code>T</code> 的接收者的、带有 <code>operator</code> 修饰符的无参数函数 <code>inc()</code>。</li><li>检查函数的返回类型是 <code>T</code> 的子类型。</li></ul><p>计算表达式的步骤是：</p><ul><li>把 <code>a</code> 的初始值存储到临时存储 <code>a0</code> 中，</li><li>把 <code>a.inc()</code> 结果赋值给 <code>a</code>，</li><li>把 <code>a0</code> 作为表达式的结果返回。</li></ul><p>对于 <code>a--</code>，步骤是完全类似的。</p><p>对于<em>前缀</em>形式 <code>++a</code> 和 <code>--a</code> 以相同方式解析，其步骤是：</p><ul><li>把 <code>a.inc()</code> 结果赋值给 <code>a</code>，</li><li>把 <code>a</code> 的新值作为表达式结果返回。</li></ul><h4 id="二元操作算术运算符"><a href="#二元操作算术运算符" class="headerlink" title="二元操作算术运算符"></a>二元操作算术运算符</h4><table><thead><tr><th>表达式</th><th>翻译为</th></tr></thead><tbody><tr><td>a + b</td><td>a.plus(b)</td></tr><tr><td>a - b</td><td>a.minus(b)</td></tr><tr><td>a * b</td><td>a.times(b)</td></tr><tr><td>a / b</td><td>a.div(b)</td></tr><tr><td>a % b</td><td>a.rem(b)、 a.mod(b) （已弃用）</td></tr><tr><td>a..b</td><td>a.rangeTo(b)</td></tr></tbody></table><p>对于此表中的操作，编译器只是解析成<em>翻译为</em>列中的表达式。</p><p>请注意，自 Kotlin 1.1 起支持 <code>rem</code> 运算符。Kotlin 1.0 使用 <code>mod</code> 运算符，它在<br>Kotlin 1.1 中被弃用。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面是一个从给定值起始的 Counter 类的示例，它可以使用重载的 <code>+</code> 运算符来增加计数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>(<span class="keyword">val</span> dayIndex: <span class="built_in">Int</span>) &#123;</div><div class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(increment: <span class="type">Int</span>)</span></span>: Counter &#123;</div><div class="line">        <span class="keyword">return</span> Counter(dayIndex + increment)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="In操作符"><a href="#In操作符" class="headerlink" title="In操作符"></a>In操作符</h4><table><thead><tr><th>表达式</th><th>翻译为</th></tr></thead><tbody><tr><td>a in b</td><td>b.contains(a)</td></tr><tr><td>a !in b</td><td>!b.contains(a)</td></tr></tbody></table><p>对于 <code>in</code> 和 <code>!in</code>，过程是相同的，但是参数的顺序是相反的。</p><h4 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h4><table><thead><tr><th>表达式</th><th>翻译为</th></tr></thead><tbody><tr><td>a[i]</td><td>a.get(i)</td></tr><tr><td>a[i, j]</td><td>a.get(i, j)</td></tr><tr><td>a[i_1, ……,  i_n]</td><td>a.get(i_1, ……,  i_n)</td></tr><tr><td>a[i] = b</td><td>a.set(i, b)</td></tr><tr><td>a[i, j] = b</td><td>a.set(i, j, b)</td></tr><tr><td>a[i_1, ……,  i_n] = b</td><td>a.set(i_1, ……, i_n, b)</td></tr></tbody></table><p>方括号转换为调用带有适当数量参数的 <code>get</code> 和 <code>set</code>。</p><h4 id="调用操作符"><a href="#调用操作符" class="headerlink" title="调用操作符"></a>调用操作符</h4><table><thead><tr><th>表达式</th><th>翻译为</th></tr></thead><tbody><tr><td>a()</td><td>a.invoke()</td></tr><tr><td>a(i)</td><td>a.invoke(i)</td></tr><tr><td>a(i, j)</td><td>a.invoke(i, j)</td></tr><tr><td>a(i_1, ……,  i_n)</td><td>a.invoke(i_1, ……,  i_n)</td></tr></tbody></table><p>圆括号转换为调用带有适当数量参数的 <code>invoke</code>。</p><h4 id="广义赋值"><a href="#广义赋值" class="headerlink" title="广义赋值"></a>广义赋值</h4><table><thead><tr><th>表达式</th><th>翻译为</th></tr></thead><tbody><tr><td>a += b</td><td>a.plusAssign(b)</td></tr><tr><td>a -= b</td><td>a.minusAssign(b)</td></tr><tr><td>a *= b</td><td>a.timesAssign(b)</td></tr><tr><td>a /= b</td><td>a.divAssign(b)</td></tr><tr><td>a %= b</td><td>a.remAssign(b), a.modAssign(b)（已弃用）</td></tr></tbody></table><p>对于赋值操作，例如 <code>a += b</code>，编译器执行以下步骤：</p><ul><li>如果右列的函数可用<ul><li>如果相应的二元函数（即 <code>plusAssign()</code> 对应于 <code>plus()</code>）也可用，那么报告错误（模糊）。</li><li>确保其返回类型是 <code>Unit</code>，否则报告错误。</li><li>生成 <code>a.plusAssign(b)</code> 的代码</li></ul></li><li>否则试着生成 <code>a = a + b</code> 的代码（这里包含类型检查：<code>a + b</code> 的类型必须是 <code>a</code> 的子类型）。</li></ul><p><em>注意</em>：赋值在 Kotlin 中<em>不是</em>表达式。</p><h4 id="相等与不等操作符"><a href="#相等与不等操作符" class="headerlink" title="相等与不等操作符"></a>相等与不等操作符</h4><table><thead><tr><th>表达式</th><th>翻译为</th></tr></thead><tbody><tr><td>a == b</td><td>a?.equals(b) ?: (b === null)</td></tr><tr><td>a != b</td><td>!(a?.equals(b) ?: (b === <code>null</code>))</td></tr></tbody></table><p><em>注意</em>：<code>===</code> 和 <code>!==</code>（同一性检查）不可重载，因此不存在对他们的约定</p><p>这个 <code>==</code> 操作符有些特殊：它被翻译成一个复杂的表达式，用于筛选 <code>null</code> 值。<br><code>null == null</code>  总是 true，对于非空的 <code>x</code>，<code>x == null</code> 总是 false 而不会调用 <code>x.equals()</code>。</p><h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><table><thead><tr><th>表达式</th><th>翻译为</th></tr></thead><tbody><tr><td>a &gt; b</td><td>a.compareTo(b) &gt; 0</td></tr><tr><td>a &lt; b</td><td>a.compareTo(b) &lt; 0</td></tr><tr><td>a &gt;= b</td><td>a.compareTo(b) &gt;= 0</td></tr><tr><td>a &lt;= b</td><td>a.compareTo(b) &lt;= 0</td></tr></tbody></table><p>所有的比较都转换为对 <code>compareTo</code> 的调用，这个函数需要返回 <code>Int</code> 值</p><h4 id="属性委托操作符"><a href="#属性委托操作符" class="headerlink" title="属性委托操作符"></a>属性委托操作符</h4><p><code>provideDelegate</code>、 <code>getValue</code> 以及 <code>setValue</code> 操作符函数已在<a href="#委托属性">委托属性</a>中描述。</p><h4 id="命名函数的中缀调用"><a href="#命名函数的中缀调用" class="headerlink" title="命名函数的中缀调用"></a>命名函数的中缀调用</h4><p>我们可以通过<a href="#中缀表示法">中缀函数的调用</a> 来模拟自定义中缀操作符。</p><h3 id="类型相等性"><a href="#类型相等性" class="headerlink" title="类型相等性"></a>类型相等性</h3><p>Kotlin 中有两种类型的相等性：</p><ul><li>引用相等（两个引用指向同一对象）</li></ul><ul><li>结构相等（用 equals() 检查）</li></ul><h4 id="引用相等"><a href="#引用相等" class="headerlink" title="引用相等"></a>引用相等</h4><p>引用相等由 <code>===</code>（以及其否定形式 <code>!==</code>）操作判断。<code>a === b</code> 当且仅当 a 和 b 指向同一个对象时求值为 true。</p><h4 id="结构相等"><a href="#结构相等" class="headerlink" title="结构相等"></a>结构相等</h4><p>结构相等由 <code>==</code>（以及其否定形式 <code>!=</code>）操作判断。按照惯例，像 <code>a == b</code> 这样的表达式会翻译成</p><p><code>a?.equals(b) ?: (b === null)</code></p><p>也就是说如果 <code>a</code> 不是 <code>null</code> 则调用 <code>equals(Any?)</code> 函数，否则（即 <code>a</code> 是 <code>null</code>）检查 <code>b</code> 是否与 <code>null</code> 引用相等。</p><p>请注意，当与 <code>null</code> 显式比较时完全没必要优化你的代码：<code>a == null</code> 会被自动转换为 <code>a=== null</code>。同类型才有可比性。</p><h3 id="This表达式"><a href="#This表达式" class="headerlink" title="This表达式"></a>This表达式</h3><p>为了表示当前的 <em>接收者</em> 我们使用 <em>this</em> 表达式：</p><ul><li>在<a href="https://www.kotlincn.net/docs/reference/classes.html#继承" target="_blank" rel="external">类</a>的成员中，<em>this</em> 指的是该类的当前对象</li><li>在<a href="https://www.kotlincn.net/docs/reference/extensions.html" target="_blank" rel="external">扩展函数</a>或者<a href="https://www.kotlincn.net/docs/reference/lambdas.html#带接收者的函数字面值" target="_blank" rel="external">带接收者的函数字面值</a>中， <em>this</em> 表示在点左侧传递的 <em>接收者</em> 参数。</li></ul><p>如果 <em>this</em> 没有限定符，它指的是最内层的包含它的作用域。要引用其他作用域中的 <em>this</em>，请使用 <em>标签限定符</em>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> kotlinThisExpression = KotlinThisExpression()</div><div class="line">    println(kotlinThisExpression.leftReference() === kotlinThisExpression)</div><div class="line">    kotlinThisExpression.InnerKotlinThisExpression().test()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinThisExpression</span> </span>&#123;</div><div class="line">    <span class="keyword">val</span> thisClassObject <span class="keyword">get</span>() = <span class="keyword">this</span></div><div class="line"></div><div class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">KotlinThisExpression</span> </span>&#123;</div><div class="line">        <span class="comment">//val thisClassObject get() = this@KotlinThisExpression //不明确label</span></div><div class="line">        <span class="keyword">val</span> thisClassObject <span class="keyword">get</span>() = <span class="keyword">this</span> <span class="comment">//内部类名相同,不能用限定的 this</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">InnerKotlinThisExpression</span> </span>&#123; <span class="comment">// 隐式标签 @InnerKotlinThisExpression</span></div><div class="line">        <span class="function"><span class="keyword">fun</span> InnerKotlinThisExpression.<span class="title">fuck</span><span class="params">()</span></span> &#123; <span class="comment">// 隐式标签 @fuck</span></div><div class="line">            <span class="keyword">val</span> a = <span class="keyword">this</span><span class="symbol">@KotlinThisExpression</span> <span class="comment">// KotlinThisExpression 的 this</span></div><div class="line">            <span class="keyword">val</span> b = <span class="keyword">this</span><span class="symbol">@InnerKotlinThisExpression</span> <span class="comment">// InnerKotlinThisExpression 的 this</span></div><div class="line"></div><div class="line">            <span class="keyword">val</span> c = <span class="keyword">this</span> <span class="comment">// fuck() 的接收者，一个 InnerKotlinThisExpression</span></div><div class="line">            <span class="keyword">val</span> d = <span class="keyword">this</span><span class="symbol">@fuck</span> <span class="comment">// fuck() 的接收者，一个 InnerKotlinThisExpression</span></div><div class="line"></div><div class="line">            <span class="keyword">val</span> label = <span class="symbol">label@</span> <span class="function"><span class="keyword">fun</span> String.<span class="params">()</span></span> &#123;</div><div class="line">                println(<span class="keyword">this</span>)<span class="comment">// label 的接收者</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="string">"label"</span>.label()</div><div class="line">            <span class="keyword">val</span> lambda = &#123; -&gt;</div><div class="line">                <span class="comment">// fuck() 的接收者，因为它包含的 lambda 表达式</span></div><div class="line">                <span class="comment">// 没有任何接收者</span></div><div class="line">                println(<span class="keyword">this</span>)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            lambda()</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</div><div class="line">            fuck()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> KotlinThisExpression.<span class="title">leftReference</span><span class="params">()</span></span> = <span class="keyword">this</span>.thisClassObject <span class="comment">//this 表示在点左侧传递的 接收者 参数。</span></div></pre></td></tr></table></figure><h3 id="Nothing-类型"><a href="#Nothing-类型" class="headerlink" title="Nothing 类型"></a>Nothing 类型</h3><p>如果用 <code>null</code> 来初始化一个要推断类型的值，而又没有其他信息可用于确定更具体的类型时，编译器会推断出 <code>Nothing?</code> 类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> nothingInt<span class="comment">/*: Nothing?*/</span> = <span class="literal">null</span></div><div class="line"><span class="keyword">val</span> list:List&lt;<span class="built_in">Nothing</span>?&gt; = listOf(<span class="literal">null</span>)</div></pre></td></tr></table></figure><p>另外Kotlin 中 <code>throw</code> 是表达式, 表达式的类型是特殊类型 <code>Nothing</code>。 该类型没有值，而是用于标记永远不能达到的代码位置。<code>Nothing</code> 可以用来标记一个永远不会返回的函数, 也可以作为 Elvis 表达式的一部分：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> nothingInt<span class="comment">/*: Nothing?*/</span> = <span class="literal">null</span></div><div class="line"><span class="keyword">val</span> list: List&lt;<span class="built_in">Nothing</span>?&gt; = listOf(<span class="literal">null</span>)</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">(message: <span class="type">String</span>)</span></span>: <span class="built_in">Nothing</span> &#123;</div><div class="line">    <span class="keyword">throw</span> IllegalArgumentException(message)</div><div class="line">&#125;</div><div class="line">fail(<span class="string">"fail"</span>)</div><div class="line"><span class="comment">//作为 Elvis 表达式的一部分 </span></div><div class="line"><span class="keyword">var</span> exception = <span class="literal">null</span> ?: <span class="keyword">throw</span> RuntimeException(<span class="string">"throw"</span>)</div></pre></td></tr></table></figure><h3 id="解构声明"><a href="#解构声明" class="headerlink" title="解构声明"></a>解构声明</h3><p>解构声明是创建多个变量与对象<code>componentN</code> 函数对应起来。例如在上面的数据类中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> (name, age) = KotlinDataClass.User(<span class="string">"Lisa"</span>, <span class="number">18</span>)</div></pre></td></tr></table></figure><p>NOTE: <code>componentN()</code> 函数需要用 <code>operator</code> 关键字标记，以允许在解构声明中使用它们。它可以用<em>for</em>-循环、</p><p><em>map</em>-映射, 以及 lambda 表达式中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> (name, age) = KotlinDeconstruction.Person(<span class="string">"jack"</span>, <span class="number">32</span>)</div><div class="line">    println(<span class="string">"<span class="subst">$name</span> <span class="subst">$age</span>"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">val</span> request = KotlinDeconstruction.request()</div><div class="line">    <span class="keyword">val</span> (rs, code) = request</div><div class="line">    println(<span class="string">"result = <span class="subst">$rs</span> , code = <span class="subst">$code</span>"</span>)</div><div class="line">    <span class="comment">//下划线用于未使用的变量</span></div><div class="line">    <span class="keyword">val</span> (_, responseCode) = request</div><div class="line">    println(responseCode)</div><div class="line">    println(request.component1())</div><div class="line">    println(request.component2())</div><div class="line"></div><div class="line">    <span class="comment">//解构声明和Map</span></div><div class="line">    <span class="keyword">val</span> map = mutableMapOf&lt;String, String&gt;()</div><div class="line">    <span class="keyword">for</span> (it <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</div><div class="line">        map.put(it.toString(), it.toString())</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> ((k, v) <span class="keyword">in</span> map) &#123;</div><div class="line">        println(<span class="string">"map key = <span class="subst">$k</span>, value = <span class="subst">$v</span>"</span>)</div><div class="line">    &#125;</div><div class="line">    map.mapValues &#123; entry -&gt; println(<span class="string">"key = <span class="subst">$&#123;entry.key&#125;</span>, value = <span class="subst">$&#123;entry.value&#125;</span>!"</span>) &#125;</div><div class="line">    map.mapValues &#123; (key, value) -&gt; println(<span class="string">"key = <span class="subst">$key</span>, value = <span class="subst">$value</span>!"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinDeconstruction</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</div><div class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span>: Any = name</div><div class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span>: Any = age</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span></span>(<span class="keyword">val</span> result: String, <span class="keyword">val</span> code: <span class="built_in">Int</span>)</div><div class="line"></div><div class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</div><div class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>: Response &#123;</div><div class="line">            <span class="comment">//request network</span></div><div class="line">            <span class="keyword">return</span> Response(<span class="string">"ok"</span>, <span class="number">200</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解构声明的好处, 如request 函数时要返回两个东西时,用它爽爆了。因为编译器始终会创建多个变量接收,效率并不比之前用对象的高。但实际上并不需要解析一个对象里的大量变量,否则通过对象 <code>.</code>属性获取值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> (name, age) = person <span class="comment">//编译器会生成如下两句代码</span></div><div class="line"><span class="keyword">val</span> name = person.component1()</div><div class="line"><span class="keyword">val</span> age = person.component2()</div></pre></td></tr></table></figure><h3 id="相等性"><a href="#相等性" class="headerlink" title="相等性"></a>相等性</h3><p>Kotlin 中有两种类型的相等性：</p><ul><li>引用相等（两个引用指向同一对象）</li><li>结构相等（用 <code>equals()</code> 检查）</li></ul><h4 id="引用相等-1"><a href="#引用相等-1" class="headerlink" title="引用相等"></a>引用相等</h4><p>引用相等由 <code>===</code>（以及其否定形式 <code>!==</code>）操作判断。<code>a === b</code> 当且仅当 <code>a</code> 和 <code>b</code> 指向同一个对象时求值为 true。</p><h4 id="结构相等-1"><a href="#结构相等-1" class="headerlink" title="结构相等"></a>结构相等</h4><p>结构相等由 <code>==</code>（以及其否定形式 <code>!=</code>）操作判断。按照惯例，像 <code>a == b</code> 这样的表达式会翻译成</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a?.equals(b) ?: (b === <span class="literal">null</span>)</div></pre></td></tr></table></figure><p>也就是说如果 <code>a</code> 不是 <code>null</code> 则调用 <code>equals(Any?)</code> 函数，否则（即 <code>a</code> 是 <code>null</code>）检查 b 是否与 <code>null</code> 引用相等。</p><p>请注意，当与 <code>null</code> 显式比较时完全没必要优化你的代码：<code>a == null</code> 会被自动转换为 <code>a=== null</code>。</p><h4 id="浮点数相等性"><a href="#浮点数相等性" class="headerlink" title="浮点数相等性"></a>浮点数相等性</h4><p>当相等性检测的两个操作数都是静态已知的（可空或非空的）<code>Float</code> 或 <code>Double</code> 类型时，该检测遵循 IEEE 754 浮点数运算标准。</p><p>否则会使用不符合该标准的结构相等性检测，这会导致 <code>NaN</code> 等于其自身，而 <code>-0.0</code> 不等于 <code>0.0</code>。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h4><p>Kotlin 中所有异常类都是 <code>Throwable</code> 类的子孙类。 每个异常都有消息、堆栈回溯信息和可选的原因。</p><p>使用 <em>throw</em>-表达式来抛出异常：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> MyException(<span class="string">"Hi There!"</span>)</div></pre></td></tr></table></figure><p>使用 <em>try</em>-表达式来捕获异常：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 一些代码</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (e: SomeException) &#123;</div><div class="line">    <span class="comment">// 处理程序</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 可选的 finally 块</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以有零到多个 <em>catch</em> 块。<em>finally</em> 块可以省略。 但是 <em>catch</em> 和 <em>finally</em> 块至少应该存在一个。</p><h4 id="Try-是一个表达式"><a href="#Try-是一个表达式" class="headerlink" title="Try 是一个表达式"></a>Try 是一个表达式</h4><p><em>try</em> 是一个表达式，即它可以有一个返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span>? = <span class="keyword">try</span> &#123; parseInt(input) &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123; <span class="literal">null</span> &#125;</div></pre></td></tr></table></figure><p><em>try</em>-表达式的返回值是 <em>try</em> 块中的最后一个表达式或者是（所有）<em>catch</em> 块中的最后一个表达式。 <em>finally</em> 块中的内容不会影响表达式的结果。</p><h4 id="受检的异常"><a href="#受检的异常" class="headerlink" title="受检的异常"></a>受检的异常</h4><p>Kotlin 没有受检的异常。这其中有很多原因，但我们会提供一个简单的例子。</p><p>以下是 JDK 中 <code>StringBuilder</code> 类实现的一个示例接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Appendable append(CharSequence csq) throws IOException;</div></pre></td></tr></table></figure><p>这个签名是什么意思？ 它是说，每次我追加一个字符串到一些东西（一个 <code>StringBuilder</code>、某种日志、一个控制台等）上时我就必须捕获那些 <code>IOException</code>。 为什么？因为它可能正在执行 IO 操作（<code>Writer</code> 也实现了 <code>Appendable</code>）…… 所以它导致这种代码随处可见的出现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    log.append(message)</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    <span class="comment">// 必须要安全</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这并不好，参见<a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" target="_blank" rel="external">《Effective Java》</a> 第 65 条：<em>不要忽略异常</em>。</p><p>Bruce Eckel 在<a href="http://www.mindview.net/Etc/Discussions/CheckedExceptions" target="_blank" rel="external">《Java 是否需要受检的异常？》（Does Java need Checked Exceptions?）</a> 中指出：</p><blockquote><p>通过一些小程序测试得出的结论是异常规范会同时提高开发者的生产力和代码质量，但是大型软件项目的经验表明一个不同的结论——生产力降低、代码质量很少或没有提高。</p></blockquote><p>其他相关引证：</p><ul><li><a href="http://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html" target="_blank" rel="external">《Java 的受检异常是一个错误》（Java’s checked exceptions were a mistake）</a>（Rod Waldhoff）</li><li><a href="http://www.artima.com/intv/handcuffs.html" target="_blank" rel="external">《受检异常的烦恼》（The Trouble with Checked Exceptions）</a>（Anders Hejlsberg）</li></ul><p> 注意：<code>throw</code> 表达式的类型是特殊类型 <code>Nothing</code>。参见<a href="#Nothing-类型">Nothing类型</a></p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射是这样的一组语言和库功能，它允许在运行时自省你的程序的结构。 Kotlin 让语言中的函数和属性做为一等公民、并对其自省（即在运行时获悉一个名称或者一个属性或函数的类型）与简单地使用函数式或响应式风格紧密相关。</p><blockquote><p>在 Java 平台上，使用反射功能所需的运行时组件作为单独的 JAR 文件（<code>kotlin-reflect.jar</code>）分发。这样做是为了减少不使用反射功能的应用程序所需的运行时库的大小。如果你需要使用反射，请确保该 .jar文件添加到项目的 classpath 中。</p></blockquote><h4 id="类引用"><a href="#类引用" class="headerlink" title="类引用"></a>类引用</h4><p>最基本的反射功能是获取 Kotlin 类的运行时引用。要获取对静态已知的 Kotlin 类的引用，可以使用 <em>类字面值</em> 语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> c = MyClass::<span class="class"><span class="keyword">class</span></span></div></pre></td></tr></table></figure><p>该引用是 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html" target="_blank" rel="external">KClass</a> 类型的值。</p><p>请注意，Kotlin 类引用与 Java 类引用不同。要获得 Java 类引用， 请在 <code>KClass</code> 实例上使用 <code>.java</code> 属性。</p><h4 id="绑定的类引用（自-1-1-起）"><a href="#绑定的类引用（自-1-1-起）" class="headerlink" title="绑定的类引用（自 1.1 起）"></a>绑定的类引用（自 1.1 起）</h4><p>通过使用对象作为接收者，可以用相同的 <code>::class</code> 语法获取指定对象的类的引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> widget: Widget = ……</div><div class="line">assert(widget <span class="keyword">is</span> GoodWidget) &#123; <span class="string">"Bad widget: <span class="subst">$&#123;widget::class.qualifiedName&#125;</span>"</span> &#125;</div></pre></td></tr></table></figure><p>你可以获取对象的精确类的引用，例如 <code>GoodWidget</code> 或 <code>BadWidget</code>，尽管接收者表达式的类型是 <code>Widget</code>。</p><h4 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h4><p>当我们有一个命名函数声明如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isOdd</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x % <span class="number">2</span> != <span class="number">0</span></div></pre></td></tr></table></figure><p>我们可以很容易地直接调用它（<code>isOdd(5)</code>），但是我们也可以把它作为一个值传递。例如传给另一个函数。 为此，我们使用 <code>::</code> 操作符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">println(numbers.filter(::isOdd)) <span class="comment">// 输出 [1, 3]</span></div></pre></td></tr></table></figure><p>这里 <code>::isOdd</code> 是函数类型 <code>(Int) -&gt; Boolean</code> 的一个值。</p><p>当上下文中已知函数期望的类型时，<code>::</code> 可以用于重载函数。 例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isOdd</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x % <span class="number">2</span> != <span class="number">0</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isOdd</span><span class="params">(s: <span class="type">String</span>)</span></span> = s == <span class="string">"brillig"</span> || s == <span class="string">"slithy"</span> || s == <span class="string">"tove"</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">println(numbers.filter(::isOdd)) <span class="comment">// 引用到 isOdd(x: Int)</span></div></pre></td></tr></table></figure><p>或者，你可以通过将方法引用存储在具有显式指定类型的变量中来提供必要的上下文：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> predicate: (String) -&gt; <span class="built_in">Boolean</span> = ::isOdd   <span class="comment">// 引用到 isOdd(x: String)</span></div></pre></td></tr></table></figure><p>如果我们需要使用类的成员函数或扩展函数，它需要是限定的。 例如 <code>String::toCharArray</code> 为类型 <code>String</code>提供了一个扩展函数：<code>String.() -&gt; CharArray</code>。</p><h4 id="示例：函数组合"><a href="#示例：函数组合" class="headerlink" title="示例：函数组合"></a>示例：函数组合</h4><p>考虑以下函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B, C&gt;</span> <span class="title">compose</span><span class="params">(f: (<span class="type">B</span>)</span></span> -&gt; C, g: (A) -&gt; B): (A) -&gt; C &#123;</div><div class="line">    <span class="keyword">return</span> &#123; x -&gt; f(g(x)) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它返回一个传给它的两个函数的组合：<code>compose(f, g) = f(g(*))</code>。 现在，你可以将其应用于可调用引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">length</span><span class="params">(s: <span class="type">String</span>)</span></span> = s.length</div><div class="line"></div><div class="line"><span class="keyword">val</span> oddLength = compose(::isOdd, ::length)</div><div class="line"><span class="keyword">val</span> strings = listOf(<span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"abc"</span>)</div><div class="line"></div><div class="line">println(strings.filter(oddLength)) <span class="comment">// 输出 "[a, abc]"</span></div></pre></td></tr></table></figure><h4 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h4><p>要把属性作为 Kotlin中 的一等对象来访问，我们也可以使用 <code>::</code> 运算符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    println(::x.<span class="keyword">get</span>()) <span class="comment">// 输出 "1"</span></div><div class="line">    ::x.<span class="keyword">set</span>(<span class="number">2</span>)</div><div class="line">    println(x)         <span class="comment">// 输出 "2"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>表达式 <code>::x</code> 求值为 <code>KProperty&lt;Int&gt;</code> 类型的属性对象，它允许我们使用 <code>get()</code> 读取它的值，或者使用 <code>name</code> 属性来获取属性名。更多信息请参见<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/index.html" target="_blank" rel="external">关于 <code>KProperty</code> 类的文档</a>。</p><p>对于可变属性，例如 <code>var y = 1</code>，<code>::y</code> 返回 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-mutable-property/index.html" target="_blank" rel="external"><code>KMutableProperty</code></a> 类型的一个值， 该类型有一个 <code>set()</code> 方法。</p><p>属性引用可以用在不需要参数的函数处：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> strs = listOf(<span class="string">"a"</span>, <span class="string">"bc"</span>, <span class="string">"def"</span>)</div><div class="line">println(strs.map(String::length)) <span class="comment">// 输出 [1, 2, 3]</span></div></pre></td></tr></table></figure><p>要访问属于类的成员的属性，我们这样限定它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> p: <span class="built_in">Int</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> prop = A::p</div><div class="line">    println(prop.<span class="keyword">get</span>(A(<span class="number">1</span>))) <span class="comment">// 输出 "1"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于扩展属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> String.lastChar: <span class="built_in">Char</span></div><div class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>[length - <span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    println(String::lastChar.<span class="keyword">get</span>(<span class="string">"abc"</span>)) <span class="comment">// 输出 "c"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="与-Java-反射的互操作性"><a href="#与-Java-反射的互操作性" class="headerlink" title="与 Java 反射的互操作性"></a>与 Java 反射的互操作性</h4><p>在Java平台上，标准库包含反射类的扩展，它提供了与 Java 反射对象之间映射（参见 <code>kotlin.reflect.jvm</code>包）。 例如，要查找一个用作 Kotlin 属性 getter 的 幕后字段或 Java方法，可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> kotlin.reflect.jvm.*</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(<span class="keyword">val</span> p: <span class="built_in">Int</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    println(A::p.javaGetter) <span class="comment">// 输出 "public final int A.getP()"</span></div><div class="line">    println(A::p.javaField)  <span class="comment">// 输出 "private final int A.p"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>要获得对应于 Java 类的 Kotlin 类，请使用 <code>.kotlin</code> 扩展属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getKClass</span><span class="params">(o: <span class="type">Any</span>)</span></span>: KClass&lt;Any&gt; = o.javaClass.kotlin</div></pre></td></tr></table></figure><h4 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h4><p>构造函数可以像方法和属性那样引用。他们可以用于期待这样的函数类型对象的任何地方：它与该构造函数接受相同参数并且返回相应类型的对象。 通过使用 <code>::</code> 操作符并添加类名来引用构造函数。考虑下面的函数， 它期待一个无参并返回 <code>Foo</code> 类型的函数参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">(factory: ()</span></span> -&gt; Foo) &#123;</div><div class="line">    <span class="keyword">val</span> x: Foo = factory()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用 <code>::Foo</code>，类 Foo 的零参数构造函数，我们可以这样简单地调用它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function(::Foo)</div></pre></td></tr></table></figure><h4 id="绑定的函数与属性引用（自-1-1-起）"><a href="#绑定的函数与属性引用（自-1-1-起）" class="headerlink" title="绑定的函数与属性引用（自 1.1 起）"></a>绑定的函数与属性引用（自 1.1 起）</h4><p>你可以引用特定对象的实例方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numberRegex = <span class="string">"\\d+"</span>.toRegex()</div><div class="line">println(numberRegex.matches(<span class="string">"29"</span>)) <span class="comment">// 输出“true”</span></div><div class="line"> </div><div class="line"><span class="keyword">val</span> isNumber = numberRegex::matches</div><div class="line">println(isNumber(<span class="string">"29"</span>)) <span class="comment">// 输出“true”</span></div></pre></td></tr></table></figure><p>取代直接调用方法 <code>matches</code> 的是我们存储其引用。 这样的引用会绑定到其接收者上。 它可以直接调用（如上例所示）或者用于任何期待一个函数类型表达式的时候：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> strings = listOf(<span class="string">"abc"</span>, <span class="string">"124"</span>, <span class="string">"a70"</span>)</div><div class="line">println(strings.filter(numberRegex::matches)) <span class="comment">// 输出“[124]”</span></div></pre></td></tr></table></figure><p>比较绑定的类型和相应的未绑定类型的引用。 绑定的可调用引用有其接收者“附加”到其上，因此接收者的类型不再是参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> isNumber: (CharSequence) -&gt; <span class="built_in">Boolean</span> = numberRegex::matches</div><div class="line"></div><div class="line"><span class="keyword">val</span> matches: (Regex, CharSequence) -&gt; <span class="built_in">Boolean</span> = Regex::matches</div></pre></td></tr></table></figure><p>属性引用也可以绑定：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> prop = <span class="string">"abc"</span>::length</div><div class="line">println(prop.<span class="keyword">get</span>())   <span class="comment">// 输出“3”</span></div></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名为现有类型提供替代名称。 如果类型名称太长，你可以另外引入较短的名称，并使用新的名称替代原类型名。可以为函数类型提供另外的别名，也可以为内部类和嵌套类创建新名称</p><p>类型别名不会引入新类型。 它们等效于相应的底层类型。 当你在代码中添加 <code>typealias Predicate&lt;T&gt;</code> 并使用 <code>Predicate&lt;Int&gt;</code> 时，Kotlin 编译器总是把它扩展为 <code>(Int) -&gt; Boolean</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> net: Net = Network()</div><div class="line"></div><div class="line">    <span class="keyword">val</span> enable = enable(net) &#123;</div><div class="line">        netStatus() == <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    println(enable)</div><div class="line"></div><div class="line">    <span class="keyword">val</span> p: Predicate&lt;<span class="built_in">Int</span>&gt; = &#123; it &gt; <span class="number">0</span> &#125;</div><div class="line">    println(listOf(<span class="number">1</span>, <span class="number">-2</span>).filter(p)) <span class="comment">// 输出 "[1]"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">typealias Net = Network</div><div class="line">typealias Node = Network.Node</div><div class="line"></div><div class="line">typealias NodeSet = Set&lt;Network.Node&gt;</div><div class="line">typealias FileTable&lt;N&gt; = MutableMap&lt;N, MutableList&lt;File&gt;&gt;</div><div class="line"></div><div class="line">typealias MyHandler = (<span class="built_in">Int</span>, String, Any) -&gt; <span class="built_in">Unit</span></div><div class="line">typealias Predicate&lt;T&gt; = (T) -&gt; <span class="built_in">Boolean</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">netStatus</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span> </span>&#123;</div><div class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">enable</span><span class="params">(t: <span class="type">T</span>, p: <span class="type">Predicate</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">    <span class="keyword">return</span> p(t)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦多，快来 Kotlin ，快速学习Kotlin！&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://lazy.github.io/categories/Kotlin/"/>
    
    
      <category term="kotlin" scheme="http://lazy.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>dev kvm is not found(Android studio)</title>
    <link href="http://lazy.github.io/2017/04/17/android/kvm-not-found/"/>
    <id>http://lazy.github.io/2017/04/17/android/kvm-not-found/</id>
    <published>2017-04-17T14:58:04.000Z</published>
    <updated>2017-05-30T15:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="AVD-突然出现了dev-kvm-is-not-found-这个错误，我猜测大概-Hardware-Accelerated-Execution-Manager-丢失了某些文件，或者没安装好HAXM"><a href="#AVD-突然出现了dev-kvm-is-not-found-这个错误，我猜测大概-Hardware-Accelerated-Execution-Manager-丢失了某些文件，或者没安装好HAXM" class="headerlink" title="AVD 突然出现了dev kvm is not found 这个错误，我猜测大概 Hardware_Accelerated_Execution_Manager 丢失了某些文件，或者没安装好HAXM"></a>AVD 突然出现了<font color="#ff0000">dev kvm is not found</font> 这个错误，我猜测大概 Hardware_Accelerated_Execution_Manager 丢失了某些文件，或者没安装好HAXM</h4><a id="more"></a><p><img src="http://img.blog.csdn.net/20160802190104824" alt="这里写图片描述"></p><p>1.从AndroidSDK 根目录 进入 extras —&gt;intel—&gt;Hardware_Accelerated_Execution_Manager—&gt;双击打开 IntelHAXM_6.0.3.dmg 文件,最后安装IntelHAXM_6.0.3.mpkg即可</p><p><img src="http://img.blog.csdn.net/20160802190502594" alt="extras"></p><p><img src="http://img.blog.csdn.net/20160802190553372" alt="intel"></p><p><img src="http://img.blog.csdn.net/20160802190628029" alt="Hardware_Accelerated_Execution_Manager"></p><p><img src="http://img.blog.csdn.net/20160802190653346" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160802190708628" alt="这里写图片描述"></p><p>Done!</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;AVD-突然出现了dev-kvm-is-not-found-这个错误，我猜测大概-Hardware-Accelerated-Execution-Manager-丢失了某些文件，或者没安装好HAXM&quot;&gt;&lt;a href=&quot;#AVD-突然出现了dev-kvm-is-not-found-这个错误，我猜测大概-Hardware-Accelerated-Execution-Manager-丢失了某些文件，或者没安装好HAXM&quot; class=&quot;headerlink&quot; title=&quot;AVD 突然出现了dev kvm is not found 这个错误，我猜测大概 Hardware_Accelerated_Execution_Manager 丢失了某些文件，或者没安装好HAXM&quot;&gt;&lt;/a&gt;AVD 突然出现了&lt;font color=#ff0000 &gt;dev kvm is not found&lt;/font&gt; 这个错误，我猜测大概 Hardware_Accelerated_Execution_Manager 丢失了某些文件，或者没安装好HAXM&lt;/h4&gt;
    
    </summary>
    
      <category term="Android问题集锦" scheme="http://lazy.github.io/categories/Android%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    
    
      <category term="AndroidStudio" scheme="http://lazy.github.io/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>ListView/RecyclerView 中正确使用 EditText CheckBox</title>
    <link href="http://lazy.github.io/2017/04/17/android/Edit-CheckBox/"/>
    <id>http://lazy.github.io/2017/04/17/android/Edit-CheckBox/</id>
    <published>2017-04-17T14:25:11.000Z</published>
    <updated>2017-12-26T14:39:41.609Z</updated>
    
    <content type="html"><![CDATA[<p> 在 ListView/RecyclerView Item 中 使用EditText CheckBox 控件时 滚动列表时 EditText 值错乱 CheckBox checked 值同样错乱，原因在于复用Item时 设置控件value时 触发了old Item 监听器回调，回调中改变了控件value<br><a id="more"></a> </p><h2 id="错误用法"><a href="#错误用法" class="headerlink" title="错误用法"></a>错误用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">checkBox.setChecked(model.isChecked);</div><div class="line">checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123;</div><div class="line">@Override</div><div class="line">public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123;</div><div class="line">model.setChecked(isChecked);///改变 DataPoJo</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="正确用法"><a href="#正确用法" class="headerlink" title="正确用法"></a>正确用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123;</div><div class="line">@Override</div><div class="line">public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123;</div><div class="line">model.setChecked(isChecked);//改变 DataPoJo</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">checkBox.setChecked(model.isChecked);</div></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p> 先设Item 监听器，Item复用时，监听器是new 的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在 ListView/RecyclerView Item 中 使用EditText CheckBox 控件时 滚动列表时 EditText 值错乱 CheckBox checked 值同样错乱，原因在于复用Item时 设置控件value时 触发了old Item 监听器回调，回调中改变了控件value&lt;br&gt;
    
    </summary>
    
      <category term="Android问题集锦" scheme="http://lazy.github.io/categories/Android%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    
    
      <category term="Android" scheme="http://lazy.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
